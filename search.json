[{"title":"经典JS闭包面试题","url":"/2017/06/14/经典JS闭包面试题/","content":"\n\n\n闭包：从字面意思来理解就是封闭和包裹，换句话说，就是在函数内部定义的变量，在函数的外部无法访问到，因此就说函数构成了一个闭包。说白了闭包是作用域的应用。计算机科学中对闭包的定义为：一个函数的函数体以及函数所处的环境，构成的一个综合体叫做：闭包函数体：就是函数内部的代码。函数所处的环境：指的就是作用域。是不是觉得计算机科学中对闭包的定义是不是很难理解。下面我就来我面试时遇到的一些闭包问题。\n\n<!--more-->\n\n## 由工作中演变而来的面试题\n\n这是一个我工作当中的遇到的一个问题，似乎很有趣，就当做了一道题去面试，发现几乎没人能全部答对并说出原因，遂拿出来聊一聊吧。\n\n先看题目代码：\n\n```bash\nfunction fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      return fun(m,n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n//问:三行a,b,c的输出分别是什么？\n```\n\n这是一道非常典型的JS闭包问题。其中嵌套了三层`fun`函数，搞清楚每层`fun`的函数是那个`fun`函数尤为重要。\n\n可以先在纸上或其他地方写下你认为的结果，然后展开看看正确答案是什么？\n\n```bash\n//答案：\n//a: undefined,0,0,0\n//b: undefined,0,1,2\n//c: undefined,0,1,1\n```\n\n都答对了么？如果都答对了恭喜你在js闭包问题当中几乎没什么可以难住你了；如果没有答对，继续往下分析。\n\n## JS中有几种函数\n\n首先，在此之前需要了解的是，在JS中函数可以分为两种，**具名函数（命名函数）**和**匿名函数**。\n\n区分这两种函数的方法非常简单，可以通过输出`fn.name`来判断，有name的就是具名函数，没有name的就是匿名函数。\n\n> 注意：在低版本IE上无法获取具名函数的name，会返回undefined，建议在火狐或是谷歌浏览器上测试。\n\n或是采用兼容IE的获取函数`name`方法来获取函数名称：\n\n```bash\n/**\n    * 获取指定函数的函数名称（用于兼容IE）\n    * @param {Function} fun 任意函数\n    */\nfunction getFunctionName(fun) {\n    if (fun.name !== undefined)\n        return fun.name;\n    var ret = fun.toString();\n    ret = ret.substr('function '.length);\n    ret = ret.substr(0, ret.indexOf('('));\n    return ret;\n}\n```\n\n遂用上述函数测试是否为匿名函数：\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-e9995a01ed05d416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n可以得知变量`fn1`是具名函数，`fn2`是匿名函数。\n\n## 创建函数的几种方式\n\n说完函数的类型，还需要了解JS中创建函数都有几种创建方法。\n\n**1、声明函数**\n\n最普通最标准的声明函数方法，包括函数名及函数体。\n\n```bash\nfunction fn1(){}\n```\n\n**2、创建匿名函数表达式**\n\n创建一个变量，这个变量的内容为一个函数\n\n```bash\nvar fn1=function (){}\n```\n\n注意采用这种方法创建的函数为**匿名函数**，即没有函数`name`\n\n```bash\nvar fn1=function (){};\ngetFunctionName(fn1).length;//0\n```\n\n**3、创建具名函数表达式**\n\n创建一个变量，内容为一个带有名称的函数。\n\n```bash\nvar fn1=function xxcanghai(){};\n```\n\n> 注意：具名函数表达式的函数名只能在创建函数内部使用\n\n即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用。\n\n测试：\n\n```bash\nvar fn1=function xxcanghai(){\n    console.log(\"in:fn1<\",typeof fn1,\">xxcanghai:<\",typeof xxcanghai,\">\");\n};\nconsole.log(\"out:fn1<\",typeof fn1,\">xxcanghai:<\",typeof xxcanghai,\">\");\nfn1();\n//out:fn1< function >xxcanghai:< undefined >\n//in:fn1< function >xxcanghai:< function >\n```\n\n可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。\n\n> 注意：在对象内定义函数如`var o={ fn : function (){…} }`，也属于函数表达式。\n\n**4、Function构造函数**\n\n可以给 `Function` 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是**匿名函数**。\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-1ba53a0815064f6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n**5、自执行函数**\n\n```bash\n(function(){alert(1);})();\n(function fn1(){alert(1);})();\n```\n\n自执行函数属于上述的“函数表达式”，规则相同\n\n**6、其他创建函数的方法**\n\n当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 `eval` ， `setTimeout` ， `setInterval` 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开。\n\n## 三个fun函数的关系是什么？\n\n说完函数类型与创建函数的方法后，就可以回归主题，看这道面试题。\n\n这段代码中出现了三个`fun`函数，所以第一步先搞清楚，这三个`fun`函数的关系，哪个函数与哪个函数是相同的。\n\n```bash\nfunction fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      //...\n    }\n  };\n}\n```\n\n先看第一个`fun`函数，属于标准具名函数声明，是**新创建**的函数，他的返回值是一个对象字面量表达式，属于一个新的object。\n\n这个新的对象内部包含一个也叫`fun`的属性，通过上述介绍可得知，属于匿名函数表达式，即`fun`这个属性中存放的是一个**新创建**匿名函数表达式。\n\n> 注意：所有**声明的匿名函数都是一个新函数。**\n\n所以第一个`fun`函数与第二个`fun`函数不相同，均为新创建的函数。\n\n## 函数作用域链的问题\n\n再说第三个`fun`函数之前需要先说下，在_函数表达式_内部能不能访问存放当前函数的变量。\n\n**测试1，对象内部的函数表达式：**\n\n```bash\nbash\nvar o={\n  fn:function (){\n    console.log(fn);\n  }\n};\no.fn();//ERROR报错\n```\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-b119cb7ac30d142e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n**测试2，非对象内部的函数表达式：**\n\nvar fn=function (){\n```bash\n  console.log(fn);\n};\nfn();//function (){console.log(fn);};正确\n```\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-ff61db72e84f3caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n结论是：使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。\n\n原因也非常简单，因为**函数作用域链**的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。\n\n所以综上所述，可以得知，**最内层的return出去的`fun`函数不是第二层`fun`函数，是最外层的`fun`函数**。\n\n所以，三个`fun`函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。\n\n## 到底在调用哪个函数？\n\n再看下原题，现在知道了程序中有两个`fun`函数(第一个和第三个相同)，遂接下来的问题是搞清楚，运行时他执行的是哪个`fun`函数？\n\n```bash\nfunction fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      return fun(m,n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n//问:三行a,b,c的输出分别是什么？\n```\n\n**1、第一行a**\n\n```bash\nvar a = fun(0); a.fun(1); a.fun(2); a.fun(3);\n```\n\n可以得知，第一个`fun(0)`是在调用**第一层`fun`函数**。第二个`fun(1)`是在调用前一个`fun`的返回值的`fun`函数，所以：  \n第后面几个`fun(1)`,`fun(2)`,`fun(3)`,函数都是在调用**第二层`fun`函数**。\n\n遂：\n\n在第一次调用`fun(0)`时，`o`为`undefined`；\n\n第二次调用`fun(1)`时`m`为`1`，此时`fun`闭包了外层函数的`n`，也就是第一次调用的`n=0`，即`m=1`，`n=0`，并在内部调用第一层`fun`函数`fun(1,0);`所以`o`为`0`；\n\n第三次调用`fun(2)`时`m`为`2`，但依然是调用`a.fun`，所以还是闭包了第一次调用时的n，所以内部调用第一层的`fun(2,0);`所以`o`为`0`\n\n第四次同理；\n\n即：最终答案为`undefined,0,0,0`\n\n**2、第二行b**\n\n```bash\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\n```\n\n先从`fun(0)`开始看，肯定是调用的第一层`fun`函数；而他的返回值是一个对象，所以第二个`fun(1)`调用的是第二层`fun`函数，后面几个也是调用的第二层`fun`函数。\n\n遂：\n\n在第一次调用第一层`fun(0)`时，`o`为`undefined`；\n\n第二次调用 `.fun(1)`时`m`为`1`，此时`fun`闭包了外层函数的`n`，也就是第一次调用的`n=0`，即`m=1`，`n=0`，并在内部调用第一层`fun`函数`fun(1,0);`所以`o`为`0`；\n\n第三次调用 `.fun(2)`时`m`为`2`，此时当前的`fun`函数不是第一次执行的返回对象，而是**第二次执行的返回对象**。而在第二次执行第一层`fun`函数时时`(1,0)`所以`n=1`,`o=0`,返回时闭包了第二次的`n`，遂在第三次调用第三层`fun`函数时`m=2`,`n=1`，即调用第一层`fun`函数`fun(2,1)`，所以`o`为`1`；\n\n第四次调用 `.fun(3)`时`m`为`3`，闭包了第三次调用的`n`，同理，最终调用第一层`fun`函数为`fun(3,2)`；所以`o`为`2`；\n\n即最终答案：`undefined,0,1,2`\n\n**3、第三行c**\n\n```bash\nvar c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined,?,?,?\n```\n\n根据前面两个例子，可以得知：\n\n`fun(0)`为执行第一层`fun`函数，`.fun(1)`执行的是`fun(0)`返回的第二层`fun`函数，这里语句结束，遂`c`存放的是`fun(1)`的返回值，而不是`fun(0)`的返回值，所以`c`中闭包的也是`fun(1)`第二次执行的`n`的值。`c.fun(2)`执行的是`fun(1)`返回的第二层`fun函数`，`c.fun(3)`执行的**也**是`fun(1)`返回的第二层`fun`函数。\n\n遂：\n\n在第一次调用第一层`fun(0)`时，`o`为`undefined`；\n\n第二次调用 `.fun(1)`时`m`为`1`，此时`fun`闭包了外层函数的`n`，也就是第一次调用的`n=0`，即`m=1`，`n=0`，并在内部调用第一层`fun`函数`fun(1,0);`所以`o`为`0`；\n\n第三次调用`.fun(2)`时`m`为`2`，此时`fun`闭包的是第二次调用的`n=1`，即`m=2`，`n=1`，并在内部调用第一层`fun`函数`fun(2,1);`所以`o`为`1`；\n\n第四次`.fun(3)`时同理，但依然是调用的第二次的返回值，遂最终调用第一层`fun`函数`fun(3,1)`，所以`o`还为`1`\n\n即最终答案：`undefined,0,1,1`\n\n## 后话\n\n这段代码原本是在做一个将异步回调改写为同步调用的组件时的代码，发现了这个坑，对JS的闭包有了更深入的了解。\n\n关于什么是闭包，网上的文章数不胜数，但理解什么是闭包还是要在代码中自己去发现与领悟。\n\n如果要我说什么是闭包，我认为，广义上的闭包就是指一个变量在他自身作用域外被使用了，就叫发生了闭包。\n\n希望读者能通过本文对闭包现象有进一步的了解，如有其它见解或看法，欢迎指正或留言讨论。\n\n\n\n\n\n** 作者：[小小沧海](http://www.cnblogs.com/xxcanghai/)  **\n** 原文地址：[http://www.cnblogs.com/xxcanghai/p/4991870.html](http://www.cnblogs.com/xxcanghai/p/4991870.html) **\n\n","tags":["JavaScript"]},{"title":"强大的CSS3选择器","url":"/2017/06/14/强大的CSS3选择器/","content":"\n\n\n每个前端工程师可能每天都会写一些css，其中选择器是很主要的一部分。但是，大家可能每天写的大多是#id,.class这样的选择器，这并不稀奇，但是如果我们了解并且熟用css3为我们提供的强大并且优雅的选择器，就可以简化我们的代码。\n我在学习和整理css3的选择器的时候都不会去考虑它的浏览器的支持程度，如果有需要，可以在这里查看它的浏览器支持情况：「caniuse.com」。\n\n<!--more-->\n\n## 一、基本选择器\n\n###  1. 通配选择器 「*」\n\n``` bash\n*{margin: 0;padding: 0} //选择页面中的所有元素并设置margin和padding值为0\n.demo *{background:#000} //选择类名为demo的元素下面的所有元素并设置背景为黑色\n```\n\n\n\n### 2.元素选择器 「Element」\n\n``` bash\n body{background:#ccc} //选择body元素 \n ul{background:#fff} //选择列表ul元素\n```\n\n\n\n### 3.ID选择器 「#id」\n\n``` bash\n html:\n <div id=\"demo\"></div>\n css:\n #demo{do something}\n```\n\n\n\n### 4.类选择器 「.class」\n\n``` bash\n html:\n <ul class=\"demo\"></ul>\n css:\n .demo{do something}\n ul.demo{do something} //这样只会选择有demo类名的ul元素\n```\n\n## 二、层次选择器\n\n###  6.后代选择器「E F」\n\n选择匹配E的元素内的所有匹配F的元素。\n\n``` bash\nhtml：\n<div class=\"parent\">\n        <div class=\"child\"></div>\n        <div class=\"child\">\n             <div class=\"c-child\">\n                  <div class=\"c-c-child\"></div>\n            </div>\n        </div>    \n</div>\n\ncss:\n\n.parent div{do something} //会选择parent里面的所有div，不管是子元素.child还是孙元素.c-child和.c-c-child\n```\n\n\n\n###  7.子选择器「E > F」\n\n选择配配E的元素的匹配F的直系子元素。\n\n``` bash\nhtml：\n  <div class=\"parent\">\n          <div class=\"child\"></div>\n          <div class=\"child\">\n               <div class=\"c-child\">\n                    <div class=\"c-c-child\"></div>\n              </div>\n          </div>    \n  </div>\n \n css:\n .parent > div{do something} //只会选择.parent元素的直系子元素，也就是只会选择到 .child元素\n```\n\n\n### 8.相邻兄弟元素选择器「E + F」 \n\nE和F是同辈元素，具有相同的父元素，并且F元素紧邻在E元素的后面，此时可以使用相邻兄弟选择器。\n\n``` bash\nhtml:\n<div>\n    <div class=\"demo\">1</div>\n    <div>2</div>\n    <div>3</div>\n </div>\n \n css:\n \n .demo + div {do something}//会选中内容为2的div\n```\n\n\n### 9.通用兄弟选择器「E ~ F」\n\nE和F是同辈元素，具有相同的父元素，并且F元素在E元素之后，E ~ F将选中E元素后面的所有F元素。\n\n``` bash\nhtml:\n <div>\n     <div class=\"demo\">1</div>\n     <div>2</div>\n     <div>3</div>\n     <div>4</div>\n </div>\n \n css:\n \n.demo ~ div {do something}//会选中内容为2,3,4的div\n```\n\n\n## 三、伪类选择器\n\n### 10.动态伪类选择器「E:link,E:visited,E:active,E:hover,E:focus」\n\n``` bash\nE:link{do something} //选择定义了超链接但链接还未被访问过的元素\nE:visited{do something} //选择定义了超链接并且链接已经被访问过的元素\nE:active{do something} //选择匹配的E元素，且元素被激活，常用在锚点和按钮上\nE:hover{do something} //选择鼠标停留的匹配的E元素\nE:focus{do something} //选择匹配的E元素，且元素获得焦点\n```\n\n### 11.目标伪类选择器「E:target」\n\n选择匹配E的所有元素，且匹配元素被相关URL指向。\n\n\n### 12.语言伪类选择器「E:lang(language)」\n\n用来选择指定了lang属性的元素，其值为language。\n\n``` bash\n html:\n <html lang=\"en-US\"></html>\n \n css:\n :lang(en-US) {do something}\n有时候网页切换不同的语言版本的时候，可以通过这个选择器做一些特殊的处理。\n```\n\n\n### 13.状态伪类选择器「E:checked,E:enabled,E:disabled」\n\n```bash\nE:checked{do something} //匹配表单中被选中的单选按钮或复选按钮\nE:enabled{do something} //匹配所有起用的表单元素\nE:disabled{do something} //匹配所有禁用的表单元素\n```\n\n### 14.结构伪类选择器「E:first-child,E:last-child,E:root,E:nth-child(n),E:nth-last-child(n),E:nth-of-type(n),E:nth-last-of-type(n),E:first-of-type,E:last-of-type,E:only-child,E:only-of-type,E:empty」\n\n \n\n### 14.1 [E:first-child]\n\n用来选取特定元素的第一个子元素。\n\n```bash\nhtml:\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n</ul>\ncss:\nul > li:first-child {do something} //用来选取ul中的第一个li元素\n```\n\n\n### 14.2 [E:last-child]\n\n用来选取特定元素的最后一个子元素。\n\n```bash\n html:\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n     <li>4</li>\n     <li>5</li>\n </ul>\n css:\n ul > li:last-child {do something} //用来选取ul中的最后一个li元素\n```\n\n\n### 14.3 [E:nth-child()],[E:nth-last-child()]\n\n用来选取某个父元素的一个或多个特定的子元素，其中的n可以是数值(从1开始)，也可以是包含n的表达式，也可以是odd(奇数)，even(偶数)。\n\nE:nth-last-child()选择器的使用方法于E:nth-child()是相同的，不同的是E:nth-last-child()选择的元素是从父元素的最后一个子元素开始算起。\n\n```bash\n html:\n  <ul>\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n  </ul>\ncss:\n ul > li:nth-child(2n+1) {do something} //用来选取ul中的第2n+1(奇数)个      li元素\n```\n\n\n### 14.4  [E:root]\n\n用来匹配元素E所在的文档中的根元素，在html文档中根元素就始终是html。\n\n \n\n### 14.5 [E:nth-of-type(),E:nth-last-of-type()]\n\nE:nth-of-type()只计算父元素中指定的某种类型的子元素，当某个元素的子元素类型不只是一种时，使用nth-of-type来选择会比较有用。\n\nE:nth-last-of-type()的用法同E:nth-of-type()相同，不同的是:nth-last-of-type()也是从父元素的最后一个子元素开始算起。\n\nli:nth-of-type(3)的话就会标识它只会选择第三个li元素，别的元素会忽略掉，如：\n\n```bash\n html:\n <ul>\n    <li>1</li>\n    <li>2</li>\n    <div>3</div>\n    <div>4</div>\n    <li>5</li>\n    <li>6</li>\n    <li>7</li>\n    <li>8</li>\n</ul> \nul > li:nth-of-type(3){do something} //会选中内容为5的li元素 \n```\n但是使用nth-child就会是这样：\n\n```bash\n html:\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <div>3</div>\n    <div>4</div>\n    <li>5</li>\n    <li>6</li>\n    <li>7</li>\n    <li>8</li>\n</ul>\nul > li:nth-child(3){do something} //会选中内容为3的div元素\n```\n\n\n### 14.6 [E:first-of-type,E:last-of-type]\n\n:first-of-type和:last-of-type这两个选择器类似于:first-child和:last-child，不同的就是指定了元素的类型。\n\n```bash\nhtml:\n <ul>\n     <div>1</div>\n     <div>2</div>\n     <li>3</li>\n     <li>4</li>\n     <li>5</li>\n     <li>6</li>\n</ul>\nCSS：\nul > li:first-of-type{do something} //会选中内容为3的li元素\n```\n\n\n###  14.7 [E:only-child]\n\n#### 匹配的元素E是其父元素的唯一子元素，也就是说匹配元素的父元素只有一个子元素。\n\n```bash\nhtml:\n<div class=\"demo\">\n   <p>1-1</p>\n   <p>1-2</p>\n</div>\n<div class=\"demo\">\n   <p>2-1</p>\n</div>\ncss:\n.demo > p:only-child{do something}//会选取到内容为2-1的p元素\n```\n\n\n### 14.8 [E:only-of-type]\n\n####  :only-of-type用来选择一个元素，他的类型在他父元素的所有子元素中是唯一的。也就是说，一个父元素有很多子元素，而其中只有一个子元素的类型是唯一的，那么就可以使用:only-of-type来选取这个元素。\n\n这个属性说起来有点绕口，写了个简陋的demo说明意思：[查看源码][运行demo]\n\n \n\n### 14.9 [E:empty]\n\n#### :empty用来选择没有任何内容的元素，哪怕是一个空格都没有的元素。\n\n \n\n### 15 否定伪类选择器「E:not(F)」\n\n#### 可以用来选取所有除了F外的所有元素。\n\n```bash\n1 input:not([type=submit]){do something} //可以用来给表单的所有input元素定义样式，除了submit按钮之外\n```\n\n\n## 四、伪元素\n\n#### 以前我们使用的伪元素是:first-letter,:first-line,:before,:after,这样的。但css3定义的伪元素变成了双冒号，主要用来区分伪类和伪元素。对于IE6-8,仅支持单冒号表示方法，但是其他现代浏览器两种表示方法是都可以的，也就是说在现代浏览器中伪元素使用双冒号和单冒号都是会识别的。\n\n### 16. 「::first-letter」\n\n##### ::first-letter用来选择文本块的第一个字母,常用于文本排版方面。\n\n```bash\n html：\n <div>\n     <p>this is test line.....</p>\n </div>\ncss:\ndiv p::first-letter{do something} //将会选中<p>中的第一个字母t\n```\n\n\n### 17. 「::first-line」\n\n#### ::first-line用于匹配元素的第一行文本，也是常用于文本排版。\n\n```bash\nhtml：\n  <div>\n      <p>\n         this is first line..........省略.......\n         this is the second line ...省略....\n     </p>\n  </div>\n css:\ndiv p::first-line{do something} //将会选中<p>中的第一行文字\n```\n\n\n### 18. 「::before,::after」\n\n#### ::before,::after同我们之前熟用的:before和:after使用方法相同，它们不是指存于标记中的内容，是配合使用content属性可以插入额外内容的位置，尽管生成的内容不会成为DOM的一部分，但它同样可以设置样式。\n\n \n\n### 19. 「::selection」\n\n#### css3新定义的伪元素::selection用来匹配突出显示的文本。但是使用前需要确认浏览器对它的支持程度。\n\n#### 浏览器默认的情况下，我们选中的文本背景是蓝色，字体是白色。通过使用::selection，我们可以改变它的效果。\n\n#### 1 ::selection{background:#ccc;color:red} //这样改写后我们选中的文本背景颜色和文字颜色就可以自定义了\n#### 但是需要注意的是，::selection仅接受两个属性，一个是background，一个是color。\n\n \n\n## 五、属性选择器\n\n#### 在html中，通过给元素添加属性，给以给元素添加一些附加的信息，属性选择器就可以通过定位属性来选取特定的元素。\n\n###  20. 「 E[attr] 」\n\n用来选择有某个属性的元素，不论这个属性的值是什么。\n\n```bash\nhtml:\n<div id=\"demo\">\n  <a href=\"\" id=\"test\"></a>\n  <a href=\"www.taobao.com\" class=\"taobao\"></a>\n  <a href=\"#\"  id=\"show\">\n</div>\ncss:\na[id]{do something} //将会选择具有id属性的a标签\n```\n\n\n###  21. 「 E[attr=val] 」\n\n用来选取具有属性attr并且属性值为val的元素。\n\n```bash\nhtml:\n<div id=\"demo\">\n  <a href=\"\" id=\"test\" title=\"test\"></a>\n  <a href=\"www.taobao.com\" class=\"taobao\"></a>\n  <a href=\"#\"  id=\"show\" title=\"test\">\n/div>\ncss:\na[id=test][title]{do something} //将会选择具有id属性值为test且具有title属性的a标签\n```\n\n\n### 22. 「 E[attr|=val] 」\n\nE[attr|=val]用来选择具有属性attr且属性的值为val或以val-开头的元素(其中-是不可或缺的)。\n\n```bash\nhtml:\n <div id=\"demo\">\n   <a href=\"\" id=\"test\" title=\"test\" lang=\"zh\"></a>\n   <a href=\"www.taobao.com\" class=\"taobao\" lang=\"zh-cn\"></a>\n   <a href=\"#\"  id=\"show\" title=\"test\">\n</div>\ncss:\n a[lang|=zh]{do something} //将会选择具有lang属性值为zh或属性值以zh开头的a标签\n```\n\n\n### 23. 「 E[attr~=val] 」\n\n当某个元素的某个属性具有多个用空格隔开的属性值，此时使用E[attr~=val]只要attr属性多个属性值中有一个于val匹配元素就会被选中。\n\n```bash\nhtml:\n <div id=\"demo\">\n   <a href=\"\" id=\"test\" title=\"test first\"></a>\n   <a href=\"www.taobao.com\" class=\"taobao web\" title=\"second test\">      \n   <a href=\"#\"  id=\"show\" title=\"test\">\n</div>\n css:\n a[title~=test]{do something} //将会选择具有title属性且其中一个属性值为test的a标签\n```\n\n\n### 24. 「 E[attr*=val] 」\n\n这个属性选择器使用了通配符，用来选择具有属性attr并且只要属性值中包含val字符串的元素。也就是说只要所选属性中有val字符串，不管是不是多个用空格分隔的属性值，都将被选中。\n\n```bash\nhtml:\n   <div id=\"demo\">\n     <a href=\"\" id=\"test\" title=\"test first\"></a>\n     <a href=\"www.taobao.com\" class=\"taobao web\" title=\"secondtest\">       </a>\n     <a href=\"#\"  id=\"show\" title=\"testlink\">\n  </div>\n css:\n   a[title*=test]{do something} //将会选择具有title属性且其属性值包含test字符串的a标签\n```","tags":["CSS3"]}]