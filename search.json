[{"title":"vue.js开发坏境搭建","url":"/2017/07/04/vue-js开发坏境搭建/","content":"Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。\n\nVue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。\n\n\n<!--more-->\n\n#  vue.js开发环境搭建\n\n### 1.安装[Node.js](http://lib.csdn.net/base/nodejs \"Node.js知识库\")(http://www.runoob.com/nodejs/nodejs-install-setup.html)\n\n### 2.基于[node.js](http://lib.csdn.net/base/nodejs \"Node.js知识库\"),利用淘宝npm镜像安装相关依赖\n\n 在cmd里直接输入：npm install -g cnpm –registry=[https://registry.npm.taobao.org](https://registry.npm.taobao.org/)，回车，等待安装...\n\n### 3.安装全局vue-cli脚手架,用于帮助搭建所需的模板框架\n\n在cmd里 1)输入：cnpm install -g vue-cli，回车，等待安装...\n\n            2).输入：vue，回车，若出现vue信息说明表示成功\n\n### 4.创建项目\n\n在cmd里输入：vue init webpack vue_test(项目文件夹名)，回车，等待一小会儿，依次出现‘[Git](http://lib.csdn.net/base/git \"Git知识库\")’下的项，可按下图操作\n\n![](http://images2015.cnblogs.com/blog/1000531/201611/1000531-20161104114221752-1894187307.png)\n\n### 5.安装依赖\n\n在cmd里  1).输入：cd vue_test（项目名），回车，进入到具体项目文件夹\n\n             2).输入：cnpm install，回车，等待一小会儿\n\n回到项目文件夹，会发现项目结构里，多了一个node_modules文件夹（该文件里的内容就是之前安装的依赖）\n\n基于脚手架创建的默认项目结构如下图所示：\n\n![](http://images2015.cnblogs.com/blog/1000531/201611/1000531-20161104120244799-2006728410.png)\n\n###  6.[测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")环境是否搭建成功\n\n**方法1：在cmd里输入：cnpm run dev**\n\n**方法2：在浏览里输入：localhost:8080(默认端口为8080) **\n\n运行起来后的效果如下图所示：\n\n![](http://images2015.cnblogs.com/blog/1000531/201611/1000531-20161104121102221-395461091.png)\n\n参照原文：http://blog.csdn[.NET](http://lib.csdn.net/base/dotnet \".NET知识库\")/luckylqh/article/details/52863026\n\n####  注：安装过程中的坑  \n**执行cnpm run dev时候报以下错误**\n\n>To use this template, you must update following to modules:    npm: 2.15.1 should be >= 3.0.0  \n解：cmd 中执行 \n\n>把npm升级一下就可以了，npm install npm@latest -g 这句命令行就是升级到最新版的\n\n\n\n\n** 原文地址：http://blog.csdn.NET/luckylqh/article/details/52863026 **\n","tags":["前端"]},{"title":"常见布局","url":"/2017/06/12/移动Web开发中的常见布局方式及一些常见问题/","content":"\n\n\n目前针对web前端页面的设计主要分为pc端和移动端页面，针对不同的页面我们可能会采取不同的布局格式，在整个布局的选择上，没有一成不变的，也没有任何一种布局能够满足各个方面的需要，在众多的布局方式中，我这边主要针对以下几种布局方式简单的发表一下个人的看法。\n\n<!--more-->\n\n## 一、流式布局\n\n### 1.1 什么是流式布局\n\n> 流式布局就是百分比布局，通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充，同时会设定最小宽度和最大宽度，适用于图片比较多的首页、门户、电商等。\n\n在这里我们以京东的M站为例进行说明：\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/4482400-2b608551fead622a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n\n<div class=\"image-caption\">top.png</div>\n\n</div>\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/4482400-8c5716e275322263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n\n<div class=\"image-caption\">nav.png</div>\n\n</div>\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/4482400-f56df7bfbe811978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n\n<div class=\"image-caption\">navs.png</div>\n\n</div>\n\n可以看到，在京东各个模块的主容器中，都设置了最大最小宽度和宽度100%，而在导航区块中，由于一行有5个小区块，所以设置了宽度为20%，使得小区块也能达到自适应的效果。\n\n### 1.2 viewport\n\n> 在移动端用来承载网页的这个区域就是我们的视觉窗口`viewport`，这个区域可以设置高度宽度，可以按比例放大缩小，而且能设置是否允许用户自行缩放。\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/4482400-66a102b49c8b3e35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n\n<div class=\"image-caption\">viewport.jpg</div>\n\n</div>\n\n*   **width**：设置的是`viewport`宽度，可以设置`device-width`特殊值。\n*   **initial-scale**：初始缩放比，大于0的数字，一般设置为1.0。\n*   **maximum-scale**：最大缩放比，大于0的数字。\n*   **minimum-scale**：最小缩放比，大于0的数字。\n*   **user-scalable**：用户是否可以缩放，yes或no（1或0）。\n\n    <!--视口标签通可以使用 meta:vp + tab 来快速生成，通常我们可以设置为下边这样。-->\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,user-scalable=0\"/>\n\n### 1.3 移动端常见事件\n\n#### 1.3.1 touch事件\n\n*   **touchstart**：当手指触碰屏幕时候发生。不管当前有多少只手指。\n*   **touchmove**：当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用`event`的`preventDefault()`可以阻止默认情况的发生：阻止页面滚动。\n*   **touchend**：当手指离开屏幕时触发。\n*   **touchcancel**：系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面`alert()`一个提示框，此时会触发该事件，这个事件比较少用。\n\n> 触摸事件的响应顺序：\n>\n> ontouchstart --> ontouchmove --> ontouchend --> onclick(300ms延时)。\n\n#### 1.3.2 event事件\n\n*   **originalEvent**：（原生事件）是`jquery`封装的事件。\n*   **targetTouches**：目标元素的所有当前触摸。\n*   **changedTouches**：页面上最新更改的所有触摸。\n*   **touches**：页面上的所有触摸。注意：在`touchend`事件的时候`event`只会记录`changedtouches`。\n\n## 二、响应式开发\n\n### 2.1 响应式开发简介\n\n#### 2.1.1 什么是响应式开发\n\n> 在移动互联日益成熟的时候，我们在桌面浏览器上开发的网页已经无法满足移动设备的阅读。\n>\n> 通常的做法是针对移动端单独做一套特定的版本。\n>\n> 但是如果终端越来越多那么你需要开发的版本就会越来越多（大屏移动设备普及）。\n>\n> 那么`Ethan Marcotte`在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端。\n\n#### 2.1.2 响应式开发的前景\n\n> 现在的移动设备屏幕越来越大。\n>\n> 越来越多的设计师也采用了这种设计。\n>\n> 在新建站的一些网站现在普遍采用的响应式开发。\n>\n> 那么在前端开发当中也是一项必备的技能。\n\n#### 2.1.3 响应式开发的原理\n\n> CSS3中的`Media Query`（媒介查询），通过查询`screen`的宽度来指定某个宽度区间的网页布局。\n\n*   超小屏幕：768px以下（移动设备）。\n*   小屏设备：768px-992px。\n*   中等屏幕：992px-1200px。\n*   宽屏设备：1200px以上。\n\n### 2.2 Bootstrap框架\n\n#### 2.2.1 Bootstrap简介\n\n*   [官方网站](http://getbootstrap.com)\n*   [Bootstrap中文网](http://www.bootcss.com/)\n*   它是由`Twitter`的设计师`Mark Otto`和`Jacob Thornton`合作开发，是一个`CSS/HTML`框架。它提供了优雅的`HTML`和`CSS`规范，它即是由动态`CSS`语言`Less`写成。\n*   `Bootstrap`是基于`HTML5`和`CSS3`开发的，它在`jQuery`的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分`jQuery`插件。\n*   `Bootstrap`中包含了丰富的`Web`组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站。其中包括以下组件：下拉菜单、按钮组、按钮下拉菜单、导航、导航条、路径导航、分页、排版、缩略图、警告对话框、进度条、媒体对象等。\n\n#### 2.2.2 Bootstrap常用样式\n\n*   **container类**：用于定义一个固定宽度且居中的版心。\n\n  ``` bash\n    <div class=\"topbar\">\n      <div class=\"container\">\n        <!--\n          此处的代码会显示在一个固定宽度且居中的容器中\n          该容器的宽度会跟随屏幕的变化而变化\n        -->\n      </div>\n    </div>\n  ```\n\n*   **栅格系统**：`Bootstrap`中定义了一套响应式的网格系统，其使用方式就是将一个容器划分成12列，然后通过`col-xx-xx`的类名控制每一列的占比。\n\n    1.  **row类**：\n\n        *   因为每一个列默认有一个15px的左右外边距。\n        *   `row`类的一个作用就是通过左右-15px屏蔽掉这个边距。\n\n            <div class=\"container\">\n              <div class=\"row\"></div>\n            </div>\n\n    2.  **col-xx-x类**：\n\n        *   第一个连接符后边写屏幕尺寸，有`xs`超小屏幕 手机(<768px)、`sm`小屏幕 平板 (≥768px)、`md`中等屏幕 桌面显示器(≥992px)、`lg`大屏幕 大桌面显示器 (≥1200px)四种。\n        *   第二个连接符后边表示对应的份数，占12份中的几份。\n\n            <div class=\"row\">\n              <div class=\"col-md-2 text-center\"></div>\n              <div class=\"col-md-5 text-center\"></div>\n              <div class=\"col-md-2 text-center\"></div>\n              <div class=\"col-md-3 text-center\"></div>\n            </div>\n\n*   **hidden类**：设置在不同的屏幕下隐藏。\n\n  ```bash\n    <div class=\"hidden-xs,hidden-sm,hidden-md,hidden-lg\">\n  ```\n\n  ```bash\n    </div>\n  ```\n\n*   **text-xx类**：设置文字的对齐方式。\n\n  ```bash\n    text-center     文本居中\n    text-left         文本左对齐\n    text-right     文本右对齐\n  ```\n\n*   **pull-xx类**：设置浮动。\n\n  ```bash\n    pull-left         左浮动类\n    pull-right     右浮动类\n  ```\n\n*   **center-block类**：让一个固定宽度的元素居中。\n\n#### 2.2.3 字体图标\n\n*   字体图标：\n\n  ```bash\n    @font-face {\n      font-family: 'XXX';\n      src: url('../font/MiFie-Web-Font.eot') format('embedded-opentype'), \n      url('../font/MiFie-Web-Font.svg') format('svg'), \n      url('../font/MiFie-Web-Font.ttf') format('truetype'), \n      url('../font/MiFie-Web-Font.woff') format('woff');\n    }\n  ```\n\n*   字体文件格式：\n\n    *   `eot`：`embedded-opentype`\n    *   `svg`：`svg`\n    *   `ttf`：`truetype`\n    *   `woff`：`woff`\n\n#### 2.2.4 轮播图插件 Carousel\n\n*   基本的轮播图实现：\n\n  ```bash\n    <!-- \n      以下容器就是整个轮播图组件的整体，\n      注意该盒子必须加上 class=\"carousel slide\" data-ride=\"carousel\" 表示当前是一个轮播图\n      bootstrap.js会自动为当前元 素添加图片轮播的特效\n    -->\n    <div id=\"轮播图的ID\" class=\"carousel slide\" data-ride=\"carousel\">\n      <!-- ol标签是图片轮播的控制点 -->\n      <ol class=\"carousel-indicators\">\n        <!-- \n          每一个li就是一个单独的控制点\n            data-target属性就是指定当前控制点控制的是哪一个轮播图，其目的是如果界面上有多个轮播图，便于区分到底控制哪一个\n            data-slide-to属性是指当前的li元素绑定的是第几个轮播项\n          注意，默认必须给其中某个li加上active，展示的时候就是焦点项目\n        -->\n        <li data-target=\"#轮播图的ID\" data-slide-to=\"0\" class=\"active\"></li>\n        <li data-target=\"#轮播图的ID\" data-slide-to=\"1\"></li>\n        <!-- ...更多的 -->\n      </ol>\n      <!-- \n        .carousel-inner是所有轮播项的容器盒子，\n        注意role=\"listbox\"代表当前div是一个列表盒子，作用就是给当前div添加一个语义\n      -->\n      <div class=\"carousel-inner\" role=\"listbox\">\n        <!-- 每一个.item就是单个轮播项目，注意默认要给第一个轮播项目加上active，表示为焦点 -->\n        <div class=\"item active\">\n          <!-- 轮播项目中展示的图片 -->\n          ![](example.jpg)\n          <div class=\"carousel-caption\">\n            <!-- 标题或说明性文字，如果不需要，直接删除当前div.carousel-caption -->\n          </div>\n        </div>\n        <div class=\"item\">\n          <!-- ... -->\n        </div>\n        <!-- ... -->\n      </div>\n      <!-- 图片轮播上左右两个控制按钮，分别点击可以滚动到上一张和下一张 -->\n      <!-- 此处需要注意的是 该a链接的href属性必须指向需要控制的轮播图ID -->\n      <!-- 另外a链接中的data-slide=\"prev\"代表点击该链接会滚到上一张，如果设置为next的话则相反 -->\n      <a class=\"left carousel-control\" href=\"#轮播图的ID\" role=\"button\" data-slide=\"prev\">\n        <span class=\"glyphicon glyphicon-chevron-left\" aria-hidden=\"true\"></span>\n        <span class=\"sr-only\">上一张</span>\n      </a>\n      <a class=\"right carousel-control\" href=\"#轮播图的ID\" role=\"button\" data-slide=\"next\">\n        <span class=\"glyphicon glyphicon-chevron-right\" aria-hidden=\"true\"></span>\n        <span class=\"sr-only\">下一张</span>\n      </a>\n    </div>\n  ```\n\n#### 2.2.5 函数库 underscoreJS\n\n*   `_.template`：\n\n  ```bash\n    <ol class=\"carousel-indicators\">\n      <!--渲染的HTML字符串-->\n    </ol>\n    <div class=\"carousel-inner\" role=\"listbox\">\n      <!--渲染的HTML字符串-->\n    </div>\n\n    /*取到模版当中的字符串*/\n    var pointTemplateStr = $('#point_template').html();\n    var imageTemplateStr = $('#image_template').html();\n    /*转化成模版函数*/\n    var pointTemplate = _.template(pointTemplateStr);\n    var imageTemplate = _.template(imageTemplateStr);\n    /*传入数据 解析成 html 字符*/\n    var pointHtml = pointTemplate({model:data});\n    var imageHtml = imageTemplate({model:data,isMobile:isMobile});//我们只需要再加一个属性\n    /*把html字符串渲染在页面当中*/\n    $('.carousel-indicators').html(pointHtml);\n    $('.carousel-inner').html(imageHtml);\n\n    <!--点模版-->\n    <script type=\"text/template\" id=\"point_template\">\n        <%_.each(model,function(obj,i){%>\n            <li data-target=\"#carousel-example-generic\" data-slide-to=\"<%=i%>\" class=\"<%=(i==0?'active':'')%>\"></li>\n        <%})%>\n    </script>\n    <!--图片模版-->\n    <script type=\"text/template\" id=\"image_template\">\n        <%_.each(model,function(obj,i){%>\n            <div class=\"item <%=(i==0?'active':'')%>\">\n                <% if(isMobile){ %>\n                    <a href=\"#\" class=\"m_imgBox\">\n                        <img src=\"<%=obj.img%>\" alt=\"\"/>\n                    </a>\n                <%} else {%>\n                    <a href=\"#\" class=\"pc_imgBox\" style=\"background-image:url(<%=obj.bac%>)\"></a>\n                <%}%>\n            </div>\n        <%})%>\n    </script>\n  ```\n\n## 三、rem布局\n\n准备编辑这段时发现简书上已经有作者写了关于rem布局的介绍，并且他的设置比我所用的更加简洁，贴上地址供大家学习参考。  \n[手机端页面自适应解决方案—rem布局进阶版（附源码示例）](http://www.jianshu.com/p/985d26b40199)\n\n## 四、移动web开发中的常见问题\n\n### 4.1 移动端如何定义字体font-family?\n\n三大手机系统的字体：\n\n*   **iOS 系统**：\n    *   默认中文字体是`Heiti SC`\n    *   默认英文字体是`Helvetica`\n    *   默认数字字体是`HelveticaNeue`\n    *   无微软雅黑字体\n*   **Android 系统**：\n    *   默认中文字体是`Droidsansfallback`\n    *   默认英文和数字字体是`Droid Sans`\n    *   无微软雅黑字体\n*   **Winphone 系统**：\n    *   默认中文字体是`Dengxian`(方正等线体)\n    *   默认英文和数字字体是`Segoeod`\n    *   无微软雅黑字体\n\n各个手机系统有自己的默认字体，且都不支持微软雅黑，如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用`Helvetica`，三种系统都支持。\n\n```bash\n/* 移动端定义字体的代码 */\nbody{\n  font-family:Helvetica;\n}\n```\n\n### 4.2 移动端字体单位font-size选择px还是rem?\n\n*   对于只需要适配手机设备，使用`px`即可。\n\n*   对于需要适配各种移动设备，使用`rem`，例如只需要适配`iPhone`和`iPad`等分辨率差别比较挺大的设备。\n\n*   `rem`配置参考：\n\n  ```bash\n    html {font-size:10px}\n    @media screen and (min-width:480px) and (max-width:639px) {\n        html {\n            font-size: 15px\n        }\n    }\n    @media screen and (min-width:640px) and (max-width:719px) {\n        html {\n            font-size: 20px\n        }\n    }\n    @media screen and (min-width:720px) and (max-width:749px) {\n        html {\n            font-size: 22.5px\n        }\n    }\n    @media screen and (min-width:750px) and (max-width:799px) {\n        html {\n            font-size: 23.5px\n        }\n    }\n    @media screen and (min-width:800px) and (max-width:959px) {\n        html {\n            font-size: 25px\n        }\n    }\n    @media screen and (min-width:960px) and (max-width:1079px) {\n        html {\n            font-size: 30px\n        }\n    }\n    @media screen and (min-width:1080px) {\n        html {\n            font-size: 32px\n        }\n    }\n  ```\n\n### 4.3 移动端touch事件(区分webkit和winphone)有哪些？\n\n当用户手指放在移动设备在屏幕上滑动会触发的touch事件：\n\n*   **以下支持webkit**：\n    *   `touchstart`——当手指触碰屏幕时候发生。不管当前有多少只手指。\n    *   `touchmove`——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用`event``preventDefault()`可以阻止默认情况的发生：阻止页面滚动。\n    *   `touchend`——当手指离开屏幕时触发。\n    *   `touchcancel`——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面`alert()`一个提示框，此时会触发该事件，这个事件比较少用。\n*   **以下支持winphone 8**：\n    *   `MSPointerDown`——当手指触碰屏幕时候发生。不管当前有多少只手指。\n    *   `MSPointerMove`——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用`css`的`html{-ms-touch-action:none;}`可以阻止默认情况的发生：阻止页面滚动。\n    *   `MSPointerUp`——当手指离开屏幕时触发。\n\n### 4.4 如何解决移动端click屏幕产生200-300ms的延迟响应问题？\n\n> 移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。\n\n**解决方案**：\n\n*   `fastclick`可以解决在手机上点击事件的300ms延迟。\n*   `zepto`的`touch`模块，`tap`事件也是为了解决在`click`的延迟问题。\n\n**触摸事件的响应顺序**：\n\n1.  `ontouchstart`\n2.  `ontouchmove`\n3.  `ontouchend`\n4.  `onclick`\n\n解决300ms延迟的问题，也可以通过绑定`ontouchstart`事件，加快对事件的响应。\n\n### 4.5 什么是Retina 显示屏，带来了什么问题？\n\n**retina**：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的`retina`显示屏中，像素点1个变为4个。\n\n在高清显示屏中的位图被放大，图片会变得模糊，**因此移动端的视觉稿通常会设计为传统PC的2倍**。\n\n那么，前端的应对方案是：\n\n设计稿切出来的图片长宽保证为偶数，并使用`backgroud-size`把图片缩小为原来的1/2。\n\n```bash\n//例如图片宽高为：200px*200px，那么写法如下\n.css{width:100px;height:100px;background-size:100px 100px;}\n```\n\n其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px。\n\n```bash\n.css{font-size:20px}\n```\n\n### 4.6 移动端如何取消touch高亮效果？\n\n在做移动端页面时，会发现所有a标签在触发点击时或者所有设置了伪类`:active`的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过css以下方法来进行全局的禁止：\n\n```bash\nhtml {\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n```\n\n*   `ios`用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置`-webkit-tap-highlight-color`的`alpha`值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩。\n\n  ```bash\n    a,button,input,textarea{-webkit-tap-highlight-color: rgba(0,0,0,0;)}\n  ```\n\n*   `android`用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置`-webkit-tap-highlight-color的alpha`值为0去除部分机器自带的效果。\n\n  ```bash\n    a,button,input,textarea{\n        -webkit-tap-highlight-color: rgba(0,0,0,0;)\n        -webkit-user-modify:read-write-plaintext-only; \n    }\n  ```\n\n    `-webkit-user-modify`有个副作用，就是输入法不再能够输入多个字符。\n\n    另外，有些机型去除不了，如小米2。对于此类问题还有个办法，不使用`a`或者`input`标签，直接用`div`标签。\n\n*   `winphone`系统`a`、`input`标签被点击时产生的半透明灰色背景怎么去掉？\n\n  ```bash\n    <meta name=\"msapplication-tap-highlight\" content=\"no\">\n  ```\n\n### 4.7 关于webkit表单的几个问题\n\n*   `webkit`表单元素的默认外观怎么重置？\n\n  ```bash\n    .css{-webkit-appearance:none;}\n  ```\n\n*   `webkit`表单输入框`placeholder`的颜色值能改变么？\n\n  ```bash\n    input::-webkit-input-placeholder{color:#AAAAAA;}\n    input:focus::-webkit-input-placeholder{color:#EEE}\n  ```\n\n*   `webkit`表单输入框`placeholder`的文字能换行么？\n\n  ```bash\n    iOS可以，Android不行。\n  ```\n\n*   如何禁止文本缩放？\n\n    当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止：\n\n    ```bash\n    html {\n        -webkit-text-size-adjust: 100%;\n    }\n    ```\n\n    需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置`meta viewport`。\n\n### 4.8 如何在移动端禁止用户选中内容？\n\n如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉：\n\n```bash\n.user-select-none {\n  -webkit-user-select: none;  /* Chrome all / Safari all */\n  -moz-user-select: none;     /* Firefox all （移动端不需要） */\n  -ms-user-select: none;      /* IE 10+ */      \n}\n```\n\n### 4.9 如何模拟按钮的hover效果？\n\n移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用`css`的`hover`并不能满足我们的需求，还好国外有个激活`css`的`active`效果，代码如下：\n\n```bash\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\">\n<meta content=\"yes\" name=\"apple-mobile-web-app-capable\">\n<meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\">\n<meta content=\"telephone=no\" name=\"format-detection\">\n<meta content=\"email=no\" name=\"format-detection\">\n<style type=\"text/css\">\na{-webkit-tap-highlight-color: rgba(0,0,0,0);}\n.btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;}\n.btn-blue:active{background-color: #357AE8;}\n</style>\n</head>\n<body>\n\n<div class=\"btn-blue\">按钮</div>\n\n<script type=\"text/javascript\">\ndocument.addEventListener(\"touchstart\", function(){}, true)\n</script>\n</body>\n</html>\n兼容性ios5+、部分android 4+、winphone 8\n```\n\n要做到全兼容的办法，可通过绑定`ontouchstart`和`ontouchend`来控制按钮的类名。\n\n```bash\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\">\n<meta content=\"yes\" name=\"apple-mobile-web-app-capable\">\n<meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\">\n<meta content=\"telephone=no\" name=\"format-detection\">\n<meta content=\"email=no\" name=\"format-detection\">\n<style type=\"text/css\">\na{-webkit-tap-highlight-color: rgba(0,0,0,0);}\n.btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;}\n.btn-blue-on{background-color: #357AE8;}\n</style>\n</head>\n<body>\n\n<div class=\"btn-blue\">按钮</div>\n\n<script type=\"text/javascript\">\nvar btnBlue = document.querySelector(\".btn-blue\");\nbtnBlue.ontouchstart = function(){\n    this.className = \"btn-blue btn-blue-on\"\n}\nbtnBlue.ontouchend = function(){\n    this.className = \"btn-blue\"\n}\n</script>\n</body>\n</html>\n```\n\n### 4.10 屏幕旋转的事件和样式\n\n*   **事件**：`window.orientation`，取值：正负90表示横屏模式、0和180表现为竖屏模式。\n\n  ```bash\n    window.onorientationchange = function(){\n                switch(window.orientation){\n                    case -90:\n                    case 90:\n                    alert(\"横屏:\" + window.orientation);\n                    case 0:\n                    case 180:\n                    alert(\"竖屏:\" + window.orientation);\n                    break;\n                }\n    }\n  ```\n\n*   **样式**：\n\n  ```bash\n    //竖屏时使用的样式\n    @media all and (orientation:portrait) {\n        .css{}\n    }\n\n    //横屏时使用的样式\n    @media all and (orientation:landscape) {\n        .css{}\n    }\n  ```\n\n### 4.11 移动端常见的一些功能\n\n*   摇一摇功能：\n\n    `HTML5 deviceMotion`：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。\n\n*   手机拍照和上传图片：\n\n  ```bash\n    <input type=\"file\">的accept 属性\n    <!-- 选择照片 -->\n    <input type=file accept=\"image/*\">\n    <!-- 选择视频 -->\n    <input type=file accept=\"video/*\">\n  ```\n\n    使用总结：\n\n      1.  `iOS`有拍照、录像、选取本地图片功能。\n      2.  部分`android`只有选取本地图片功能。\n      3.  `winphone`不支持。\n      4.  `input`控件默认外观丑陋。\n*   消除`transition`闪屏：\n\n  ```bash\n    .css{\n        /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/\n        -webkit-transform-style: preserve-3d;\n        /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/\n        -webkit-backface-visibility: hidden;\n    }\n  ```\n\n*   开启硬件加速：\n\n    1.  解决页面闪白。\n    2.  保证动画流畅。\n\n        .css {\n        ```bash\n         -webkit-transform: translate3d(0, 0, 0);\n         -moz-transform: translate3d(0, 0, 0);\n         -ms-transform: translate3d(0, 0, 0);\n         transform: translate3d(0, 0, 0);\n        ```\n          }\n\n*   `android`上去掉语音输入按钮：\n\n  ```bash\n    input::-webkit-input-speech-button {display: none}\n  ```\n\n### 4.12 如何禁止百度转码？\n\n```bash\n<meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />\n```\n\n### 4.13 怎样默认优先使用最新版本IE和Chrome？\n\n```bash\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n```\n\n** 原文地址：http://www.jianshu.com/u/7c71a417c6c9 **","tags":["移动端"]},{"title":"HTML5本地存储和本地数据库的前世今生","url":"/2017/05/12/HTML5本地存储和本地数据库的前世今生/","content":"\n当我们在提及web前端本地存储的时候，首先需要介绍一下本地化存储的概念和历史。本地化存储从来不是一个新奇的概念，因为web应用程序一直在追求的就是媲美甚至超越桌面应用程序。但是桌面应用程序一直优于web应用程序一个很重要的原因是它的本地化存储得到了很好的支持。对于本地应用程序，操作系统会提供一个抽象层，用于存储和获取特定于应用程序的数据，这些数据可以存储于注册表、INI文件，或者其他什么地方，这取决于操作系统的实现，如果本地应用程序需要不单是键值对形式的本地存储，可以使用嵌入式数据库或其他很多种解决方案。而对于web应用程序，它的本地存储一步一步走到今天的HTML5本地存储是非常不容易的。\n\n<!--more-->\n\n#### 一、本地存储由来的背景\n\n由于HTML4时代Cookie的大小、格式、存储数据格式等限制，网站应用如果想在浏览器端存储用户的部分信息，那么只能借助于Cookie。但是Cookie的这些限制，也就导致了Cookie只能存储一些ID之类的标识符等简单的数据。\n\n下面是Cookie的限制：\n\n*   大多数浏览器支持最大为 4096 字节的Cookie。\n*   浏览器还限制站点可以在用户计算机上存储的Cookie的数量。大多数浏览器只允许每个站点存储 20 个Cookie；如果试图存储更多Cookie，则最旧的Cookie便会被丢弃。\n*   有些浏览器还会对它们将接受的来自所有站点的Cookie总数作出绝对限制，通常为 300 个。\n*   Cookie默认情况都会随着Http请求发送到后台服务器，但并不是所有请求都需要Cookie的，比如：js、css、图片等请求则不需要Cookie。\n\n为了破解Cookie的一系列限制，HTML5通过JS的新的API就能直接存储大量的数据到客户端浏览器，而且支持复杂的本地数据库，让JS更有效率。 HTML5支持两种的WebStorage：\n\n*   永久性的本地存储（localStorage）\n*   会话级别的本地存储（sessionStorage）\n\n\n\n#### 二、永久性的本地存储：localStorage\n\n在最新的JS的API中增加了localStorage对象，以便于用户存储永久存储的Web端的数据。而且数据不会随着Http请求发送到后台服务器，而且存储数据的大小机会不用考虑，因为在HTML5的标准中要求浏览器至少要支持到4MB.所以，这完全是颠覆了Cookie的限制，为Web应用在本地存储复杂的用户痕迹数据提供非常方便的技术支持。接下来就将介绍localStorage的常用的方法。\n\nlocalStorage提供了四个方法来辅助我们进行对本地存储做相关操作。\n\n*   setItem(key,value)添加本地存储数据。两个参数，非常简单就不说了。\n*   getItem(key)通过key获取相应的Value。\n*   removeItem(key)通过key删除本地数据。\n*   clear()清空数据。\n\n  ```bash\n    <script type=\"text/javascript\">\n      //添加key-value 数据到 sessionStorage\n      localStorage.setItem(\"demokey\", \"http://www.shiyanlou.com\");\n      //通过key来获取value\n      var dt = localStorage.getItem(\"demokey\");\n      alert(dt);\n      //清空所有的key-value数据。\n      //localStorage.clear();\n      alert(localStorage.length);\n    </script>\n  ```\n\n#### 三、会话级别的本地存储：sessionStorage\n\n在HTML5中增加了一个Js对象：sessionStorage；通过此对象可以直接操作存储在浏览器中的会话级别的WebStorage。存储在sessionStorage中的数据首先是Key-Value形式的，另外就是它跟浏览器当前会话相关，当会话结束后，数据会自动清除，跟未设置过期时间的Cookie类似。\n\nsessionStorage提供了四个方法来辅助我们进行对本地存储做相关操作。\n\n*   setItem(key,value)添加本地存储数据。两个参数，非常简单就不说了。\n*   getItem(key)通过key获取相应的Value。\n*   removeItem(key)通过key删除本地数据。\n*   clear()清空数据。\n\n  ```bash\n    <script type=\"text/javascript\">\n      //添加key-value 数据到 sessionStorage\n      sessionStorage.setItem(\"demokey\", \"http://blog.itjeek.com\");\n      //通过key来获取value\n      var dt = sessionStorage.getItem(\"demokey\");\n      alert(dt);\n      //清空所有的key-value数据。\n      //sessionStorage.clear();\n      alert(sessionStorage.length);\n    </script>\n  ```\n\n    #### 四、强大的本地数据\n\n    虽然HTML5已经提供了功能强大的localStorage和sessionStorage，但是他们两个都只能提供存储简单数据结构的数据，对于复杂的Web应用的数据却无能为力。逆天的是HTML5提供了一个浏览器端的数据库支持，允许我们直接通JS的API在浏览器端创建一个本地的数据库，而且支持标准的SQL的CRUD操作，让离线的Web应用更加方便的存储结构化的数据。接下里介绍一下本地数据的相关API和用法。\n\n操作本地数据库的最基本的步骤是：\n\n*   第一步：openDatabase方法：创建一个访问数据库的对象。\n*   第二步：使用第一步创建的数据库访问对象来执行transaction方法，通过此方法可以设置一个开启事务成功的事件响应方法，在事件响应方法中可以执行SQL.\n*   第三步：通过executeSql方法执行查询，当然查询可以是：CRUD。\n\n接下来分别介绍一下相关的方法的参数和用法。\n\n1、 openDatabase方法\n\n```bash\n//Demo：获取或者创建一个数据库，如果数据库不存在那么创建之\nvar dataBase = openDatabase(\"student\", \"1.0\", \"学生表\", 1024 * 1024, function () { });\n```\n\nopenDatabase方法打开一个已经存在的数据库，如果数据库不存在，它还可以创建数据库。几个参数意义分别是：\n\n*   数据库名称。\n*   数据库的版本号，目前来说传个1.0就可以了，当然可以不填；\n*   对数据库的描述。\n*   设置分配的数据库的大小（单位是kb）。\n*   回调函数(可省略)。\n\n初次调用时创建数据库，以后就是建立连接了。\n\n2.、db.transaction方法\n\n可以设置一个回调函数，此函数可以接受一个参数就是我们开启的事务的对象。然后通过此对象可以执行SQL脚本。\n\n3.、executeSql方法执行查询\n\n```bash\nts.executeSql(sqlQuery,[value1,value2..],dataHandler,errorHandler)\n```\n\n参数说明：\n\n*   qlQuery：需要具体执行的sql语句，可以是create、select、update、delete;\n*   [value1,value2..]：sql语句中所有使用到的参数的数组，在executeSql方法中，将s>语句中所要使用的参数先用“?”代替，然后依次将这些参数组成数组放在第二个参数中;\n*   dataHandler：执行成功是调用的回调函数，通过该函数可以获得查询结果集;\n*   errorHandler：执行失败时调用的回调函数;\n\n#### 综合实例\n\n```bash\n<head>\n <script src=\"Scripts/jquery-1.5.1.js\" type=\"text/javascript\"></script>\n    <script type=\"text/javascript\">\n        function initDatabase() {\n            var db = getCurrentDb();//初始化数据库\n            if(!db) {alert(\"您的浏览器不支持HTML5本地数据库\");return;}\n            db.transaction(function (trans) {//启动一个事务，并设置回调函数\n                //执行创建表的Sql脚本\n                trans.executeSql(\"create table if not exists Demo(uName text null,title text null,words text null)\", [], function (trans, result) {\n                }, function (trans, message) {//消息的回调函数alert(message);});\n            }, function (trans, result) {\n            }, function (trans, message) {\n            });\n        }\n        $(function () {//页面加载完成后绑定页面按钮的点击事件\n            initDatabase();\n            $(\"#btnSave\").click(function () {\n                var txtName = $(\"#txtName\").val();\n                var txtTitle = $(\"#txtTitle\").val();\n                var txtWords = $(\"#txtWords\").val();\n                var db = getCurrentDb();\n                //执行sql脚本，插入数据\n                db.transaction(function (trans) {\n                    trans.executeSql(\"insert into Demo(uName,title,words) values(?,?,?) \", [txtName, txtTitle, txtWords], function (ts, data) {\n                    }, function (ts, message) {\n                        alert(message);\n                    });\n                });\n                showAllTheData();\n            });\n        });\n        function getCurrentDb() {\n            //打开数据库，或者直接连接数据库参数：数据库名称，版本，概述，大小\n            //如果数据库不存在那么创建之\n            var db = openDatabase(\"myDb\", \"1.0\", \"it's to save demo data!\", 1024 * 1024); ;\n            return db;\n        }\n        //显示所有数据库中的数据到页面上去\n        function showAllTheData() {\n            $(\"#tblData\").empty();\n            var db = getCurrentDb();\n            db.transaction(function (trans) {\n                trans.executeSql(\"select * from Demo \", [], function (ts, data) {\n                    if (data) {\n                        for (var i = 0; i < data.rows.length; i++) {\n                            appendDataToTable(data.rows.item(i));//获取某行数据的json对象\n                        }\n                    }\n                }, function (ts, message) {alert(message);var tst = message;});\n            });\n        }\n        function appendDataToTable(data) {//将数据展示到表格里面\n            //uName,title,words\n            var txtName = data.uName;\n            var txtTitle = data.title;\n            var words = data.words;\n            var strHtml = \"\";\n            strHtml += \"<tr>\";\n            strHtml += \"<td>\"+txtName+\"</td>\";\n            strHtml += \"<td>\" + txtTitle + \"</td>\";\n            strHtml += \"<td>\" + words + \"</td>\";\n            strHtml += \"</tr>\";\n            $(\"#tblData\").append(strHtml);\n        }\n    </script>\n</head>\n    <body>\n        <table>\n            <tr>\n                <td>用户名：</td>\n                <td><input type=\"text\" name=\"txtName\" id=\"txtName\" required/></td>\n            </tr>\n               <tr>\n                <td>标题：</td>\n                <td><input type=\"text\" name=\"txtTitle\" id=\"txtTitle\" required/></td>\n            </tr>\n            <tr>\n                <td>留言：</td>\n                <td><input type=\"text\" name=\"txtWords\" id=\"txtWords\" required/></td>\n            </tr>\n        </table>\n        <input type=\"button\" value=\"保存\" id=\"btnSave\"/>\n        <hr/>\n        <input type=\"button\" value=\"展示所哟数据\" onclick=\"showAllTheData();\"/>\n        <table id=\"tblData\">\n        </table>\n    </body>\n</html>\n```\n\n** 作者：[如山间清爽的风](http://www.jianshu.com/u/b7dc6ae92940) **\n** 原文地址：http://www.jianshu.com/p/f9b5bc2e6b85**","tags":["HTML5"]},{"title":"经典JS闭包面试题","url":"/2017/04/12/经典JS闭包面试题/","content":"\n\n\n闭包：从字面意思来理解就是封闭和包裹，换句话说，就是在函数内部定义的变量，在函数的外部无法访问到，因此就说函数构成了一个闭包。说白了闭包是作用域的应用。计算机科学中对闭包的定义为：一个函数的函数体以及函数所处的环境，构成的一个综合体叫做：闭包函数体：就是函数内部的代码。函数所处的环境：指的就是作用域。是不是觉得计算机科学中对闭包的定义是不是很难理解。下面我就来我面试时遇到的一些闭包问题。\n\n<!--more-->\n\n## 由工作中演变而来的面试题\n\n这是一个我工作当中的遇到的一个问题，似乎很有趣，就当做了一道题去面试，发现几乎没人能全部答对并说出原因，遂拿出来聊一聊吧。\n\n先看题目代码：\n\n```bash\nfunction fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      return fun(m,n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n//问:三行a,b,c的输出分别是什么？\n```\n\n这是一道非常典型的JS闭包问题。其中嵌套了三层`fun`函数，搞清楚每层`fun`的函数是那个`fun`函数尤为重要。\n\n可以先在纸上或其他地方写下你认为的结果，然后展开看看正确答案是什么？\n\n```bash\n//答案：\n//a: undefined,0,0,0\n//b: undefined,0,1,2\n//c: undefined,0,1,1\n```\n\n都答对了么？如果都答对了恭喜你在js闭包问题当中几乎没什么可以难住你了；如果没有答对，继续往下分析。\n\n## JS中有几种函数\n\n首先，在此之前需要了解的是，在JS中函数可以分为两种，**具名函数（命名函数）**和**匿名函数**。\n\n区分这两种函数的方法非常简单，可以通过输出`fn.name`来判断，有name的就是具名函数，没有name的就是匿名函数。\n\n> 注意：在低版本IE上无法获取具名函数的name，会返回undefined，建议在火狐或是谷歌浏览器上测试。\n\n或是采用兼容IE的获取函数`name`方法来获取函数名称：\n\n```bash\n/**\n    * 获取指定函数的函数名称（用于兼容IE）\n    * @param {Function} fun 任意函数\n    */\nfunction getFunctionName(fun) {\n    if (fun.name !== undefined)\n        return fun.name;\n    var ret = fun.toString();\n    ret = ret.substr('function '.length);\n    ret = ret.substr(0, ret.indexOf('('));\n    return ret;\n}\n```\n\n遂用上述函数测试是否为匿名函数：\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-e9995a01ed05d416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n可以得知变量`fn1`是具名函数，`fn2`是匿名函数。\n\n## 创建函数的几种方式\n\n说完函数的类型，还需要了解JS中创建函数都有几种创建方法。\n\n**1、声明函数**\n\n最普通最标准的声明函数方法，包括函数名及函数体。\n\n```bash\nfunction fn1(){}\n```\n\n**2、创建匿名函数表达式**\n\n创建一个变量，这个变量的内容为一个函数\n\n```bash\nvar fn1=function (){}\n```\n\n注意采用这种方法创建的函数为**匿名函数**，即没有函数`name`\n\n```bash\nvar fn1=function (){};\ngetFunctionName(fn1).length;//0\n```\n\n**3、创建具名函数表达式**\n\n创建一个变量，内容为一个带有名称的函数。\n\n```bash\nvar fn1=function xxcanghai(){};\n```\n\n> 注意：具名函数表达式的函数名只能在创建函数内部使用\n\n即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用。\n\n测试：\n\n```bash\nvar fn1=function xxcanghai(){\n    console.log(\"in:fn1<\",typeof fn1,\">xxcanghai:<\",typeof xxcanghai,\">\");\n};\nconsole.log(\"out:fn1<\",typeof fn1,\">xxcanghai:<\",typeof xxcanghai,\">\");\nfn1();\n//out:fn1< function >xxcanghai:< undefined >\n//in:fn1< function >xxcanghai:< function >\n```\n\n可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。\n\n> 注意：在对象内定义函数如`var o={ fn : function (){…} }`，也属于函数表达式。\n\n**4、Function构造函数**\n\n可以给 `Function` 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是**匿名函数**。\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-1ba53a0815064f6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n**5、自执行函数**\n\n```bash\n(function(){alert(1);})();\n(function fn1(){alert(1);})();\n```\n\n自执行函数属于上述的“函数表达式”，规则相同\n\n**6、其他创建函数的方法**\n\n当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 `eval` ， `setTimeout` ， `setInterval` 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开。\n\n## 三个fun函数的关系是什么？\n\n说完函数类型与创建函数的方法后，就可以回归主题，看这道面试题。\n\n这段代码中出现了三个`fun`函数，所以第一步先搞清楚，这三个`fun`函数的关系，哪个函数与哪个函数是相同的。\n\n```bash\nfunction fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      //...\n    }\n  };\n}\n```\n\n先看第一个`fun`函数，属于标准具名函数声明，是**新创建**的函数，他的返回值是一个对象字面量表达式，属于一个新的object。\n\n这个新的对象内部包含一个也叫`fun`的属性，通过上述介绍可得知，属于匿名函数表达式，即`fun`这个属性中存放的是一个**新创建**匿名函数表达式。\n\n> 注意：所有**声明的匿名函数都是一个新函数。**\n\n所以第一个`fun`函数与第二个`fun`函数不相同，均为新创建的函数。\n\n## 函数作用域链的问题\n\n再说第三个`fun`函数之前需要先说下，在_函数表达式_内部能不能访问存放当前函数的变量。\n\n**测试1，对象内部的函数表达式：**\n\n```bash\nbash\nvar o={\n  fn:function (){\n    console.log(fn);\n  }\n};\no.fn();//ERROR报错\n```\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-b119cb7ac30d142e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n**测试2，非对象内部的函数表达式：**\n\nvar fn=function (){\n```bash\n  console.log(fn);\n};\nfn();//function (){console.log(fn);};正确\n```\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-ff61db72e84f3caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n结论是：使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。\n\n原因也非常简单，因为**函数作用域链**的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。\n\n所以综上所述，可以得知，**最内层的return出去的`fun`函数不是第二层`fun`函数，是最外层的`fun`函数**。\n\n所以，三个`fun`函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。\n\n## 到底在调用哪个函数？\n\n再看下原题，现在知道了程序中有两个`fun`函数(第一个和第三个相同)，遂接下来的问题是搞清楚，运行时他执行的是哪个`fun`函数？\n\n```bash\nfunction fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      return fun(m,n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n//问:三行a,b,c的输出分别是什么？\n```\n\n**1、第一行a**\n\n```bash\nvar a = fun(0); a.fun(1); a.fun(2); a.fun(3);\n```\n\n可以得知，第一个`fun(0)`是在调用**第一层`fun`函数**。第二个`fun(1)`是在调用前一个`fun`的返回值的`fun`函数，所以：  \n第后面几个`fun(1)`,`fun(2)`,`fun(3)`,函数都是在调用**第二层`fun`函数**。\n\n遂：\n\n在第一次调用`fun(0)`时，`o`为`undefined`；\n\n第二次调用`fun(1)`时`m`为`1`，此时`fun`闭包了外层函数的`n`，也就是第一次调用的`n=0`，即`m=1`，`n=0`，并在内部调用第一层`fun`函数`fun(1,0);`所以`o`为`0`；\n\n第三次调用`fun(2)`时`m`为`2`，但依然是调用`a.fun`，所以还是闭包了第一次调用时的n，所以内部调用第一层的`fun(2,0);`所以`o`为`0`\n\n第四次同理；\n\n即：最终答案为`undefined,0,0,0`\n\n**2、第二行b**\n\n```bash\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\n```\n\n先从`fun(0)`开始看，肯定是调用的第一层`fun`函数；而他的返回值是一个对象，所以第二个`fun(1)`调用的是第二层`fun`函数，后面几个也是调用的第二层`fun`函数。\n\n遂：\n\n在第一次调用第一层`fun(0)`时，`o`为`undefined`；\n\n第二次调用 `.fun(1)`时`m`为`1`，此时`fun`闭包了外层函数的`n`，也就是第一次调用的`n=0`，即`m=1`，`n=0`，并在内部调用第一层`fun`函数`fun(1,0);`所以`o`为`0`；\n\n第三次调用 `.fun(2)`时`m`为`2`，此时当前的`fun`函数不是第一次执行的返回对象，而是**第二次执行的返回对象**。而在第二次执行第一层`fun`函数时时`(1,0)`所以`n=1`,`o=0`,返回时闭包了第二次的`n`，遂在第三次调用第三层`fun`函数时`m=2`,`n=1`，即调用第一层`fun`函数`fun(2,1)`，所以`o`为`1`；\n\n第四次调用 `.fun(3)`时`m`为`3`，闭包了第三次调用的`n`，同理，最终调用第一层`fun`函数为`fun(3,2)`；所以`o`为`2`；\n\n即最终答案：`undefined,0,1,2`\n\n**3、第三行c**\n\n```bash\nvar c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined,?,?,?\n```\n\n根据前面两个例子，可以得知：\n\n`fun(0)`为执行第一层`fun`函数，`.fun(1)`执行的是`fun(0)`返回的第二层`fun`函数，这里语句结束，遂`c`存放的是`fun(1)`的返回值，而不是`fun(0)`的返回值，所以`c`中闭包的也是`fun(1)`第二次执行的`n`的值。`c.fun(2)`执行的是`fun(1)`返回的第二层`fun函数`，`c.fun(3)`执行的**也**是`fun(1)`返回的第二层`fun`函数。\n\n遂：\n\n在第一次调用第一层`fun(0)`时，`o`为`undefined`；\n\n第二次调用 `.fun(1)`时`m`为`1`，此时`fun`闭包了外层函数的`n`，也就是第一次调用的`n=0`，即`m=1`，`n=0`，并在内部调用第一层`fun`函数`fun(1,0);`所以`o`为`0`；\n\n第三次调用`.fun(2)`时`m`为`2`，此时`fun`闭包的是第二次调用的`n=1`，即`m=2`，`n=1`，并在内部调用第一层`fun`函数`fun(2,1);`所以`o`为`1`；\n\n第四次`.fun(3)`时同理，但依然是调用的第二次的返回值，遂最终调用第一层`fun`函数`fun(3,1)`，所以`o`还为`1`\n\n即最终答案：`undefined,0,1,1`\n\n## 后话\n\n这段代码原本是在做一个将异步回调改写为同步调用的组件时的代码，发现了这个坑，对JS的闭包有了更深入的了解。\n\n关于什么是闭包，网上的文章数不胜数，但理解什么是闭包还是要在代码中自己去发现与领悟。\n\n如果要我说什么是闭包，我认为，广义上的闭包就是指一个变量在他自身作用域外被使用了，就叫发生了闭包。\n\n希望读者能通过本文对闭包现象有进一步的了解，如有其它见解或看法，欢迎指正或留言讨论。\n\n\n\n\n\n** 作者：[小小沧海](http://www.cnblogs.com/xxcanghai/)  **\n** 原文地址：[http://www.cnblogs.com/xxcanghai/p/4991870.html](http://www.cnblogs.com/xxcanghai/p/4991870.html) **\n\n","tags":["JavaScript"]},{"title":"强大的CSS3选择器","url":"/2017/03/12/强大的CSS3选择器/","content":"\n\n\n每个前端工程师可能每天都会写一些css，其中选择器是很主要的一部分。但是，大家可能每天写的大多是#id,.class这样的选择器，这并不稀奇，但是如果我们了解并且熟用css3为我们提供的强大并且优雅的选择器，就可以简化我们的代码。\n我在学习和整理css3的选择器的时候都不会去考虑它的浏览器的支持程度，如果有需要，可以在这里查看它的浏览器支持情况：「caniuse.com」。\n\n<!--more-->\n\n## 一、基本选择器\n\n###  1. 通配选择器 「*」\n\n``` bash\n*{margin: 0;padding: 0} //选择页面中的所有元素并设置margin和padding值为0\n.demo *{background:#000} //选择类名为demo的元素下面的所有元素并设置背景为黑色\n```\n\n\n\n### 2.元素选择器 「Element」\n\n``` bash\n body{background:#ccc} //选择body元素 \n ul{background:#fff} //选择列表ul元素\n```\n\n\n\n### 3.ID选择器 「#id」\n\n``` bash\n html:\n <div id=\"demo\"></div>\n css:\n #demo{do something}\n```\n\n\n\n### 4.类选择器 「.class」\n\n``` bash\n html:\n <ul class=\"demo\"></ul>\n css:\n .demo{do something}\n ul.demo{do something} //这样只会选择有demo类名的ul元素\n```\n\n## 二、层次选择器\n\n###  6.后代选择器「E F」\n\n选择匹配E的元素内的所有匹配F的元素。\n\n``` bash\nhtml：\n<div class=\"parent\">\n        <div class=\"child\"></div>\n        <div class=\"child\">\n             <div class=\"c-child\">\n                  <div class=\"c-c-child\"></div>\n            </div>\n        </div>    \n</div>\n\ncss:\n\n.parent div{do something} //会选择parent里面的所有div，不管是子元素.child还是孙元素.c-child和.c-c-child\n```\n\n\n\n###  7.子选择器「E > F」\n\n选择配配E的元素的匹配F的直系子元素。\n\n``` bash\nhtml：\n  <div class=\"parent\">\n          <div class=\"child\"></div>\n          <div class=\"child\">\n               <div class=\"c-child\">\n                    <div class=\"c-c-child\"></div>\n              </div>\n          </div>    \n  </div>\n \n css:\n .parent > div{do something} //只会选择.parent元素的直系子元素，也就是只会选择到 .child元素\n```\n\n\n### 8.相邻兄弟元素选择器「E + F」 \n\nE和F是同辈元素，具有相同的父元素，并且F元素紧邻在E元素的后面，此时可以使用相邻兄弟选择器。\n\n``` bash\nhtml:\n<div>\n    <div class=\"demo\">1</div>\n    <div>2</div>\n    <div>3</div>\n </div>\n \n css:\n \n .demo + div {do something}//会选中内容为2的div\n```\n\n\n### 9.通用兄弟选择器「E ~ F」\n\nE和F是同辈元素，具有相同的父元素，并且F元素在E元素之后，E ~ F将选中E元素后面的所有F元素。\n\n``` bash\nhtml:\n <div>\n     <div class=\"demo\">1</div>\n     <div>2</div>\n     <div>3</div>\n     <div>4</div>\n </div>\n \n css:\n \n.demo ~ div {do something}//会选中内容为2,3,4的div\n```\n\n\n## 三、伪类选择器\n\n### 10.动态伪类选择器「E:link,E:visited,E:active,E:hover,E:focus」\n\n``` bash\nE:link{do something} //选择定义了超链接但链接还未被访问过的元素\nE:visited{do something} //选择定义了超链接并且链接已经被访问过的元素\nE:active{do something} //选择匹配的E元素，且元素被激活，常用在锚点和按钮上\nE:hover{do something} //选择鼠标停留的匹配的E元素\nE:focus{do something} //选择匹配的E元素，且元素获得焦点\n```\n\n### 11.目标伪类选择器「E:target」\n\n选择匹配E的所有元素，且匹配元素被相关URL指向。\n\n\n### 12.语言伪类选择器「E:lang(language)」\n\n用来选择指定了lang属性的元素，其值为language。\n\n``` bash\n html:\n <html lang=\"en-US\"></html>\n \n css:\n :lang(en-US) {do something}\n有时候网页切换不同的语言版本的时候，可以通过这个选择器做一些特殊的处理。\n```\n\n\n### 13.状态伪类选择器「E:checked,E:enabled,E:disabled」\n\n```bash\nE:checked{do something} //匹配表单中被选中的单选按钮或复选按钮\nE:enabled{do something} //匹配所有起用的表单元素\nE:disabled{do something} //匹配所有禁用的表单元素\n```\n\n### 14.结构伪类选择器「E:first-child,E:last-child,E:root,E:nth-child(n),E:nth-last-child(n),E:nth-of-type(n),E:nth-last-of-type(n),E:first-of-type,E:last-of-type,E:only-child,E:only-of-type,E:empty」\n\n \n\n### 14.1 [E:first-child]\n\n用来选取特定元素的第一个子元素。\n\n```bash\nhtml:\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n</ul>\ncss:\nul > li:first-child {do something} //用来选取ul中的第一个li元素\n```\n\n\n### 14.2 [E:last-child]\n\n用来选取特定元素的最后一个子元素。\n\n```bash\n html:\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n     <li>4</li>\n     <li>5</li>\n </ul>\n css:\n ul > li:last-child {do something} //用来选取ul中的最后一个li元素\n```\n\n\n### 14.3 [E:nth-child()],[E:nth-last-child()]\n\n用来选取某个父元素的一个或多个特定的子元素，其中的n可以是数值(从1开始)，也可以是包含n的表达式，也可以是odd(奇数)，even(偶数)。\n\nE:nth-last-child()选择器的使用方法于E:nth-child()是相同的，不同的是E:nth-last-child()选择的元素是从父元素的最后一个子元素开始算起。\n\n```bash\n html:\n  <ul>\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n  </ul>\ncss:\n ul > li:nth-child(2n+1) {do something} //用来选取ul中的第2n+1(奇数)个      li元素\n```\n\n\n### 14.4  [E:root]\n\n用来匹配元素E所在的文档中的根元素，在html文档中根元素就始终是html。\n\n \n\n### 14.5 [E:nth-of-type(),E:nth-last-of-type()]\n\nE:nth-of-type()只计算父元素中指定的某种类型的子元素，当某个元素的子元素类型不只是一种时，使用nth-of-type来选择会比较有用。\n\nE:nth-last-of-type()的用法同E:nth-of-type()相同，不同的是:nth-last-of-type()也是从父元素的最后一个子元素开始算起。\n\nli:nth-of-type(3)的话就会标识它只会选择第三个li元素，别的元素会忽略掉，如：\n\n```bash\n html:\n <ul>\n    <li>1</li>\n    <li>2</li>\n    <div>3</div>\n    <div>4</div>\n    <li>5</li>\n    <li>6</li>\n    <li>7</li>\n    <li>8</li>\n</ul> \nul > li:nth-of-type(3){do something} //会选中内容为5的li元素 \n```\n但是使用nth-child就会是这样：\n\n```bash\n html:\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <div>3</div>\n    <div>4</div>\n    <li>5</li>\n    <li>6</li>\n    <li>7</li>\n    <li>8</li>\n</ul>\nul > li:nth-child(3){do something} //会选中内容为3的div元素\n```\n\n\n### 14.6 [E:first-of-type,E:last-of-type]\n\n:first-of-type和:last-of-type这两个选择器类似于:first-child和:last-child，不同的就是指定了元素的类型。\n\n```bash\nhtml:\n <ul>\n     <div>1</div>\n     <div>2</div>\n     <li>3</li>\n     <li>4</li>\n     <li>5</li>\n     <li>6</li>\n</ul>\nCSS：\nul > li:first-of-type{do something} //会选中内容为3的li元素\n```\n\n\n###  14.7 [E:only-child]\n\n#### 匹配的元素E是其父元素的唯一子元素，也就是说匹配元素的父元素只有一个子元素。\n\n```bash\nhtml:\n<div class=\"demo\">\n   <p>1-1</p>\n   <p>1-2</p>\n</div>\n<div class=\"demo\">\n   <p>2-1</p>\n</div>\ncss:\n.demo > p:only-child{do something}//会选取到内容为2-1的p元素\n```\n\n\n### 14.8 [E:only-of-type]\n\n####  :only-of-type用来选择一个元素，他的类型在他父元素的所有子元素中是唯一的。也就是说，一个父元素有很多子元素，而其中只有一个子元素的类型是唯一的，那么就可以使用:only-of-type来选取这个元素。\n\n这个属性说起来有点绕口，写了个简陋的demo说明意思：[查看源码][运行demo]\n\n \n\n### 14.9 [E:empty]\n\n#### :empty用来选择没有任何内容的元素，哪怕是一个空格都没有的元素。\n\n \n\n### 15 否定伪类选择器「E:not(F)」\n\n#### 可以用来选取所有除了F外的所有元素。\n\n```bash\n1 input:not([type=submit]){do something} //可以用来给表单的所有input元素定义样式，除了submit按钮之外\n```\n\n\n## 四、伪元素\n\n#### 以前我们使用的伪元素是:first-letter,:first-line,:before,:after,这样的。但css3定义的伪元素变成了双冒号，主要用来区分伪类和伪元素。对于IE6-8,仅支持单冒号表示方法，但是其他现代浏览器两种表示方法是都可以的，也就是说在现代浏览器中伪元素使用双冒号和单冒号都是会识别的。\n\n### 16. 「::first-letter」\n\n##### ::first-letter用来选择文本块的第一个字母,常用于文本排版方面。\n\n```bash\n html：\n <div>\n     <p>this is test line.....</p>\n </div>\ncss:\ndiv p::first-letter{do something} //将会选中<p>中的第一个字母t\n```\n\n\n### 17. 「::first-line」\n\n#### ::first-line用于匹配元素的第一行文本，也是常用于文本排版。\n\n```bash\nhtml：\n  <div>\n      <p>\n         this is first line..........省略.......\n         this is the second line ...省略....\n     </p>\n  </div>\n css:\ndiv p::first-line{do something} //将会选中<p>中的第一行文字\n```\n\n\n### 18. 「::before,::after」\n\n#### ::before,::after同我们之前熟用的:before和:after使用方法相同，它们不是指存于标记中的内容，是配合使用content属性可以插入额外内容的位置，尽管生成的内容不会成为DOM的一部分，但它同样可以设置样式。\n\n \n\n### 19. 「::selection」\n\n#### css3新定义的伪元素::selection用来匹配突出显示的文本。但是使用前需要确认浏览器对它的支持程度。\n\n#### 浏览器默认的情况下，我们选中的文本背景是蓝色，字体是白色。通过使用::selection，我们可以改变它的效果。\n\n#### 1 ::selection{background:#ccc;color:red} //这样改写后我们选中的文本背景颜色和文字颜色就可以自定义了\n#### 但是需要注意的是，::selection仅接受两个属性，一个是background，一个是color。\n\n \n\n## 五、属性选择器\n\n#### 在html中，通过给元素添加属性，给以给元素添加一些附加的信息，属性选择器就可以通过定位属性来选取特定的元素。\n\n###  20. 「 E[attr] 」\n\n用来选择有某个属性的元素，不论这个属性的值是什么。\n\n```bash\nhtml:\n<div id=\"demo\">\n  <a href=\"\" id=\"test\"></a>\n  <a href=\"www.taobao.com\" class=\"taobao\"></a>\n  <a href=\"#\"  id=\"show\">\n</div>\ncss:\na[id]{do something} //将会选择具有id属性的a标签\n```\n\n\n###  21. 「 E[attr=val] 」\n\n用来选取具有属性attr并且属性值为val的元素。\n\n```bash\nhtml:\n<div id=\"demo\">\n  <a href=\"\" id=\"test\" title=\"test\"></a>\n  <a href=\"www.taobao.com\" class=\"taobao\"></a>\n  <a href=\"#\"  id=\"show\" title=\"test\">\n/div>\ncss:\na[id=test][title]{do something} //将会选择具有id属性值为test且具有title属性的a标签\n```\n\n\n### 22. 「 E[attr|=val] 」\n\nE[attr|=val]用来选择具有属性attr且属性的值为val或以val-开头的元素(其中-是不可或缺的)。\n\n```bash\nhtml:\n <div id=\"demo\">\n   <a href=\"\" id=\"test\" title=\"test\" lang=\"zh\"></a>\n   <a href=\"www.taobao.com\" class=\"taobao\" lang=\"zh-cn\"></a>\n   <a href=\"#\"  id=\"show\" title=\"test\">\n</div>\ncss:\n a[lang|=zh]{do something} //将会选择具有lang属性值为zh或属性值以zh开头的a标签\n```\n\n\n### 23. 「 E[attr~=val] 」\n\n当某个元素的某个属性具有多个用空格隔开的属性值，此时使用E[attr~=val]只要attr属性多个属性值中有一个于val匹配元素就会被选中。\n\n```bash\nhtml:\n <div id=\"demo\">\n   <a href=\"\" id=\"test\" title=\"test first\"></a>\n   <a href=\"www.taobao.com\" class=\"taobao web\" title=\"second test\">      \n   <a href=\"#\"  id=\"show\" title=\"test\">\n</div>\n css:\n a[title~=test]{do something} //将会选择具有title属性且其中一个属性值为test的a标签\n```\n\n\n### 24. 「 E[attr*=val] 」\n\n这个属性选择器使用了通配符，用来选择具有属性attr并且只要属性值中包含val字符串的元素。也就是说只要所选属性中有val字符串，不管是不是多个用空格分隔的属性值，都将被选中。\n\n```bash\nhtml:\n   <div id=\"demo\">\n     <a href=\"\" id=\"test\" title=\"test first\"></a>\n     <a href=\"www.taobao.com\" class=\"taobao web\" title=\"secondtest\">       </a>\n     <a href=\"#\"  id=\"show\" title=\"testlink\">\n  </div>\n css:\n   a[title*=test]{do something} //将会选择具有title属性且其属性值包含test字符串的a标签\n```","tags":["CSS3"]}]