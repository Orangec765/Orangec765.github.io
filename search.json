[{"title":"HTML5本地存储和本地数据库的前世今生","url":"/2017/05/12/HTML5本地存储和本地数据库的前世今生/","content":"\n当我们在提及web前端本地存储的时候，首先需要介绍一下本地化存储的概念和历史。本地化存储从来不是一个新奇的概念，因为web应用程序一直在追求的就是媲美甚至超越桌面应用程序。但是桌面应用程序一直优于web应用程序一个很重要的原因是它的本地化存储得到了很好的支持。对于本地应用程序，操作系统会提供一个抽象层，用于存储和获取特定于应用程序的数据，这些数据可以存储于注册表、INI文件，或者其他什么地方，这取决于操作系统的实现，如果本地应用程序需要不单是键值对形式的本地存储，可以使用嵌入式数据库或其他很多种解决方案。而对于web应用程序，它的本地存储一步一步走到今天的HTML5本地存储是非常不容易的。\n\n<!--more-->\n\n#### 一、本地存储由来的背景\n\n由于HTML4时代Cookie的大小、格式、存储数据格式等限制，网站应用如果想在浏览器端存储用户的部分信息，那么只能借助于Cookie。但是Cookie的这些限制，也就导致了Cookie只能存储一些ID之类的标识符等简单的数据。\n\n下面是Cookie的限制：\n\n*   大多数浏览器支持最大为 4096 字节的Cookie。\n*   浏览器还限制站点可以在用户计算机上存储的Cookie的数量。大多数浏览器只允许每个站点存储 20 个Cookie；如果试图存储更多Cookie，则最旧的Cookie便会被丢弃。\n*   有些浏览器还会对它们将接受的来自所有站点的Cookie总数作出绝对限制，通常为 300 个。\n*   Cookie默认情况都会随着Http请求发送到后台服务器，但并不是所有请求都需要Cookie的，比如：js、css、图片等请求则不需要Cookie。\n\n为了破解Cookie的一系列限制，HTML5通过JS的新的API就能直接存储大量的数据到客户端浏览器，而且支持复杂的本地数据库，让JS更有效率。 HTML5支持两种的WebStorage：\n\n*   永久性的本地存储（localStorage）\n*   会话级别的本地存储（sessionStorage）\n\n\n\n#### 二、永久性的本地存储：localStorage\n\n在最新的JS的API中增加了localStorage对象，以便于用户存储永久存储的Web端的数据。而且数据不会随着Http请求发送到后台服务器，而且存储数据的大小机会不用考虑，因为在HTML5的标准中要求浏览器至少要支持到4MB.所以，这完全是颠覆了Cookie的限制，为Web应用在本地存储复杂的用户痕迹数据提供非常方便的技术支持。接下来就将介绍localStorage的常用的方法。\n\nlocalStorage提供了四个方法来辅助我们进行对本地存储做相关操作。\n\n*   setItem(key,value)添加本地存储数据。两个参数，非常简单就不说了。\n*   getItem(key)通过key获取相应的Value。\n*   removeItem(key)通过key删除本地数据。\n*   clear()清空数据。\n\n  ```bash\n    <script type=\"text/javascript\">\n      //添加key-value 数据到 sessionStorage\n      localStorage.setItem(\"demokey\", \"http://www.shiyanlou.com\");\n      //通过key来获取value\n      var dt = localStorage.getItem(\"demokey\");\n      alert(dt);\n      //清空所有的key-value数据。\n      //localStorage.clear();\n      alert(localStorage.length);\n    </script>\n  ```\n\n#### 三、会话级别的本地存储：sessionStorage\n\n在HTML5中增加了一个Js对象：sessionStorage；通过此对象可以直接操作存储在浏览器中的会话级别的WebStorage。存储在sessionStorage中的数据首先是Key-Value形式的，另外就是它跟浏览器当前会话相关，当会话结束后，数据会自动清除，跟未设置过期时间的Cookie类似。\n\nsessionStorage提供了四个方法来辅助我们进行对本地存储做相关操作。\n\n*   setItem(key,value)添加本地存储数据。两个参数，非常简单就不说了。\n*   getItem(key)通过key获取相应的Value。\n*   removeItem(key)通过key删除本地数据。\n*   clear()清空数据。\n\n  ```bash\n    <script type=\"text/javascript\">\n      //添加key-value 数据到 sessionStorage\n      sessionStorage.setItem(\"demokey\", \"http://blog.itjeek.com\");\n      //通过key来获取value\n      var dt = sessionStorage.getItem(\"demokey\");\n      alert(dt);\n      //清空所有的key-value数据。\n      //sessionStorage.clear();\n      alert(sessionStorage.length);\n    </script>\n  ```\n\n    #### 四、强大的本地数据\n\n    虽然HTML5已经提供了功能强大的localStorage和sessionStorage，但是他们两个都只能提供存储简单数据结构的数据，对于复杂的Web应用的数据却无能为力。逆天的是HTML5提供了一个浏览器端的数据库支持，允许我们直接通JS的API在浏览器端创建一个本地的数据库，而且支持标准的SQL的CRUD操作，让离线的Web应用更加方便的存储结构化的数据。接下里介绍一下本地数据的相关API和用法。\n\n操作本地数据库的最基本的步骤是：\n\n*   第一步：openDatabase方法：创建一个访问数据库的对象。\n*   第二步：使用第一步创建的数据库访问对象来执行transaction方法，通过此方法可以设置一个开启事务成功的事件响应方法，在事件响应方法中可以执行SQL.\n*   第三步：通过executeSql方法执行查询，当然查询可以是：CRUD。\n\n接下来分别介绍一下相关的方法的参数和用法。\n\n1、 openDatabase方法\n\n```bash\n//Demo：获取或者创建一个数据库，如果数据库不存在那么创建之\nvar dataBase = openDatabase(\"student\", \"1.0\", \"学生表\", 1024 * 1024, function () { });\n```\n\nopenDatabase方法打开一个已经存在的数据库，如果数据库不存在，它还可以创建数据库。几个参数意义分别是：\n\n*   数据库名称。\n*   数据库的版本号，目前来说传个1.0就可以了，当然可以不填；\n*   对数据库的描述。\n*   设置分配的数据库的大小（单位是kb）。\n*   回调函数(可省略)。\n\n初次调用时创建数据库，以后就是建立连接了。\n\n2.、db.transaction方法\n\n可以设置一个回调函数，此函数可以接受一个参数就是我们开启的事务的对象。然后通过此对象可以执行SQL脚本。\n\n3.、executeSql方法执行查询\n\n```bash\nts.executeSql(sqlQuery,[value1,value2..],dataHandler,errorHandler)\n```\n\n参数说明：\n\n*   qlQuery：需要具体执行的sql语句，可以是create、select、update、delete;\n*   [value1,value2..]：sql语句中所有使用到的参数的数组，在executeSql方法中，将s>语句中所要使用的参数先用“?”代替，然后依次将这些参数组成数组放在第二个参数中;\n*   dataHandler：执行成功是调用的回调函数，通过该函数可以获得查询结果集;\n*   errorHandler：执行失败时调用的回调函数;\n\n#### 综合实例\n\n```bash\n<head>\n <script src=\"Scripts/jquery-1.5.1.js\" type=\"text/javascript\"></script>\n    <script type=\"text/javascript\">\n        function initDatabase() {\n            var db = getCurrentDb();//初始化数据库\n            if(!db) {alert(\"您的浏览器不支持HTML5本地数据库\");return;}\n            db.transaction(function (trans) {//启动一个事务，并设置回调函数\n                //执行创建表的Sql脚本\n                trans.executeSql(\"create table if not exists Demo(uName text null,title text null,words text null)\", [], function (trans, result) {\n                }, function (trans, message) {//消息的回调函数alert(message);});\n            }, function (trans, result) {\n            }, function (trans, message) {\n            });\n        }\n        $(function () {//页面加载完成后绑定页面按钮的点击事件\n            initDatabase();\n            $(\"#btnSave\").click(function () {\n                var txtName = $(\"#txtName\").val();\n                var txtTitle = $(\"#txtTitle\").val();\n                var txtWords = $(\"#txtWords\").val();\n                var db = getCurrentDb();\n                //执行sql脚本，插入数据\n                db.transaction(function (trans) {\n                    trans.executeSql(\"insert into Demo(uName,title,words) values(?,?,?) \", [txtName, txtTitle, txtWords], function (ts, data) {\n                    }, function (ts, message) {\n                        alert(message);\n                    });\n                });\n                showAllTheData();\n            });\n        });\n        function getCurrentDb() {\n            //打开数据库，或者直接连接数据库参数：数据库名称，版本，概述，大小\n            //如果数据库不存在那么创建之\n            var db = openDatabase(\"myDb\", \"1.0\", \"it's to save demo data!\", 1024 * 1024); ;\n            return db;\n        }\n        //显示所有数据库中的数据到页面上去\n        function showAllTheData() {\n            $(\"#tblData\").empty();\n            var db = getCurrentDb();\n            db.transaction(function (trans) {\n                trans.executeSql(\"select * from Demo \", [], function (ts, data) {\n                    if (data) {\n                        for (var i = 0; i < data.rows.length; i++) {\n                            appendDataToTable(data.rows.item(i));//获取某行数据的json对象\n                        }\n                    }\n                }, function (ts, message) {alert(message);var tst = message;});\n            });\n        }\n        function appendDataToTable(data) {//将数据展示到表格里面\n            //uName,title,words\n            var txtName = data.uName;\n            var txtTitle = data.title;\n            var words = data.words;\n            var strHtml = \"\";\n            strHtml += \"<tr>\";\n            strHtml += \"<td>\"+txtName+\"</td>\";\n            strHtml += \"<td>\" + txtTitle + \"</td>\";\n            strHtml += \"<td>\" + words + \"</td>\";\n            strHtml += \"</tr>\";\n            $(\"#tblData\").append(strHtml);\n        }\n    </script>\n</head>\n    <body>\n        <table>\n            <tr>\n                <td>用户名：</td>\n                <td><input type=\"text\" name=\"txtName\" id=\"txtName\" required/></td>\n            </tr>\n               <tr>\n                <td>标题：</td>\n                <td><input type=\"text\" name=\"txtTitle\" id=\"txtTitle\" required/></td>\n            </tr>\n            <tr>\n                <td>留言：</td>\n                <td><input type=\"text\" name=\"txtWords\" id=\"txtWords\" required/></td>\n            </tr>\n        </table>\n        <input type=\"button\" value=\"保存\" id=\"btnSave\"/>\n        <hr/>\n        <input type=\"button\" value=\"展示所哟数据\" onclick=\"showAllTheData();\"/>\n        <table id=\"tblData\">\n        </table>\n    </body>\n</html>\n```\n\n** 作者：[如山间清爽的风](http://www.jianshu.com/u/b7dc6ae92940) **\n** 原文地址：http://www.jianshu.com/p/f9b5bc2e6b85**","tags":["HTML5"]},{"title":"经典JS闭包面试题","url":"/2017/04/12/经典JS闭包面试题/","content":"\n\n\n闭包：从字面意思来理解就是封闭和包裹，换句话说，就是在函数内部定义的变量，在函数的外部无法访问到，因此就说函数构成了一个闭包。说白了闭包是作用域的应用。计算机科学中对闭包的定义为：一个函数的函数体以及函数所处的环境，构成的一个综合体叫做：闭包函数体：就是函数内部的代码。函数所处的环境：指的就是作用域。是不是觉得计算机科学中对闭包的定义是不是很难理解。下面我就来我面试时遇到的一些闭包问题。\n\n<!--more-->\n\n## 由工作中演变而来的面试题\n\n这是一个我工作当中的遇到的一个问题，似乎很有趣，就当做了一道题去面试，发现几乎没人能全部答对并说出原因，遂拿出来聊一聊吧。\n\n先看题目代码：\n\n```bash\nfunction fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      return fun(m,n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n//问:三行a,b,c的输出分别是什么？\n```\n\n这是一道非常典型的JS闭包问题。其中嵌套了三层`fun`函数，搞清楚每层`fun`的函数是那个`fun`函数尤为重要。\n\n可以先在纸上或其他地方写下你认为的结果，然后展开看看正确答案是什么？\n\n```bash\n//答案：\n//a: undefined,0,0,0\n//b: undefined,0,1,2\n//c: undefined,0,1,1\n```\n\n都答对了么？如果都答对了恭喜你在js闭包问题当中几乎没什么可以难住你了；如果没有答对，继续往下分析。\n\n## JS中有几种函数\n\n首先，在此之前需要了解的是，在JS中函数可以分为两种，**具名函数（命名函数）**和**匿名函数**。\n\n区分这两种函数的方法非常简单，可以通过输出`fn.name`来判断，有name的就是具名函数，没有name的就是匿名函数。\n\n> 注意：在低版本IE上无法获取具名函数的name，会返回undefined，建议在火狐或是谷歌浏览器上测试。\n\n或是采用兼容IE的获取函数`name`方法来获取函数名称：\n\n```bash\n/**\n    * 获取指定函数的函数名称（用于兼容IE）\n    * @param {Function} fun 任意函数\n    */\nfunction getFunctionName(fun) {\n    if (fun.name !== undefined)\n        return fun.name;\n    var ret = fun.toString();\n    ret = ret.substr('function '.length);\n    ret = ret.substr(0, ret.indexOf('('));\n    return ret;\n}\n```\n\n遂用上述函数测试是否为匿名函数：\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-e9995a01ed05d416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n可以得知变量`fn1`是具名函数，`fn2`是匿名函数。\n\n## 创建函数的几种方式\n\n说完函数的类型，还需要了解JS中创建函数都有几种创建方法。\n\n**1、声明函数**\n\n最普通最标准的声明函数方法，包括函数名及函数体。\n\n```bash\nfunction fn1(){}\n```\n\n**2、创建匿名函数表达式**\n\n创建一个变量，这个变量的内容为一个函数\n\n```bash\nvar fn1=function (){}\n```\n\n注意采用这种方法创建的函数为**匿名函数**，即没有函数`name`\n\n```bash\nvar fn1=function (){};\ngetFunctionName(fn1).length;//0\n```\n\n**3、创建具名函数表达式**\n\n创建一个变量，内容为一个带有名称的函数。\n\n```bash\nvar fn1=function xxcanghai(){};\n```\n\n> 注意：具名函数表达式的函数名只能在创建函数内部使用\n\n即采用此种方法创建的函数在函数外层只能使用fn1不能使用xxcanghai的函数名。xxcanghai的命名只能在创建的函数内部使用。\n\n测试：\n\n```bash\nvar fn1=function xxcanghai(){\n    console.log(\"in:fn1<\",typeof fn1,\">xxcanghai:<\",typeof xxcanghai,\">\");\n};\nconsole.log(\"out:fn1<\",typeof fn1,\">xxcanghai:<\",typeof xxcanghai,\">\");\nfn1();\n//out:fn1< function >xxcanghai:< undefined >\n//in:fn1< function >xxcanghai:< function >\n```\n\n可以看到在函数外部（out）无法使用xxcanghai的函数名，为undefined。\n\n> 注意：在对象内定义函数如`var o={ fn : function (){…} }`，也属于函数表达式。\n\n**4、Function构造函数**\n\n可以给 `Function` 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是**匿名函数**。\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-1ba53a0815064f6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n**5、自执行函数**\n\n```bash\n(function(){alert(1);})();\n(function fn1(){alert(1);})();\n```\n\n自执行函数属于上述的“函数表达式”，规则相同\n\n**6、其他创建函数的方法**\n\n当然还有其他创建函数或执行函数的方法，这里不再多说，比如采用 `eval` ， `setTimeout` ， `setInterval` 等非常用方法，这里不做过多介绍，属于非标准方法，这里不做过多展开。\n\n## 三个fun函数的关系是什么？\n\n说完函数类型与创建函数的方法后，就可以回归主题，看这道面试题。\n\n这段代码中出现了三个`fun`函数，所以第一步先搞清楚，这三个`fun`函数的关系，哪个函数与哪个函数是相同的。\n\n```bash\nfunction fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      //...\n    }\n  };\n}\n```\n\n先看第一个`fun`函数，属于标准具名函数声明，是**新创建**的函数，他的返回值是一个对象字面量表达式，属于一个新的object。\n\n这个新的对象内部包含一个也叫`fun`的属性，通过上述介绍可得知，属于匿名函数表达式，即`fun`这个属性中存放的是一个**新创建**匿名函数表达式。\n\n> 注意：所有**声明的匿名函数都是一个新函数。**\n\n所以第一个`fun`函数与第二个`fun`函数不相同，均为新创建的函数。\n\n## 函数作用域链的问题\n\n再说第三个`fun`函数之前需要先说下，在_函数表达式_内部能不能访问存放当前函数的变量。\n\n**测试1，对象内部的函数表达式：**\n\n```bash\nbash\nvar o={\n  fn:function (){\n    console.log(fn);\n  }\n};\no.fn();//ERROR报错\n```\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-b119cb7ac30d142e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n**测试2，非对象内部的函数表达式：**\n\nvar fn=function (){\n```bash\n  console.log(fn);\n};\nfn();//function (){console.log(fn);};正确\n```\n\n<div class=\"image-package\">![](http://upload-images.jianshu.io/upload_images/675733-ff61db72e84f3caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  \n</div>\n\n结论是：使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。\n\n原因也非常简单，因为**函数作用域链**的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。\n\n所以综上所述，可以得知，**最内层的return出去的`fun`函数不是第二层`fun`函数，是最外层的`fun`函数**。\n\n所以，三个`fun`函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。\n\n## 到底在调用哪个函数？\n\n再看下原题，现在知道了程序中有两个`fun`函数(第一个和第三个相同)，遂接下来的问题是搞清楚，运行时他执行的是哪个`fun`函数？\n\n```bash\nfunction fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      return fun(m,n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n//问:三行a,b,c的输出分别是什么？\n```\n\n**1、第一行a**\n\n```bash\nvar a = fun(0); a.fun(1); a.fun(2); a.fun(3);\n```\n\n可以得知，第一个`fun(0)`是在调用**第一层`fun`函数**。第二个`fun(1)`是在调用前一个`fun`的返回值的`fun`函数，所以：  \n第后面几个`fun(1)`,`fun(2)`,`fun(3)`,函数都是在调用**第二层`fun`函数**。\n\n遂：\n\n在第一次调用`fun(0)`时，`o`为`undefined`；\n\n第二次调用`fun(1)`时`m`为`1`，此时`fun`闭包了外层函数的`n`，也就是第一次调用的`n=0`，即`m=1`，`n=0`，并在内部调用第一层`fun`函数`fun(1,0);`所以`o`为`0`；\n\n第三次调用`fun(2)`时`m`为`2`，但依然是调用`a.fun`，所以还是闭包了第一次调用时的n，所以内部调用第一层的`fun(2,0);`所以`o`为`0`\n\n第四次同理；\n\n即：最终答案为`undefined,0,0,0`\n\n**2、第二行b**\n\n```bash\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\n```\n\n先从`fun(0)`开始看，肯定是调用的第一层`fun`函数；而他的返回值是一个对象，所以第二个`fun(1)`调用的是第二层`fun`函数，后面几个也是调用的第二层`fun`函数。\n\n遂：\n\n在第一次调用第一层`fun(0)`时，`o`为`undefined`；\n\n第二次调用 `.fun(1)`时`m`为`1`，此时`fun`闭包了外层函数的`n`，也就是第一次调用的`n=0`，即`m=1`，`n=0`，并在内部调用第一层`fun`函数`fun(1,0);`所以`o`为`0`；\n\n第三次调用 `.fun(2)`时`m`为`2`，此时当前的`fun`函数不是第一次执行的返回对象，而是**第二次执行的返回对象**。而在第二次执行第一层`fun`函数时时`(1,0)`所以`n=1`,`o=0`,返回时闭包了第二次的`n`，遂在第三次调用第三层`fun`函数时`m=2`,`n=1`，即调用第一层`fun`函数`fun(2,1)`，所以`o`为`1`；\n\n第四次调用 `.fun(3)`时`m`为`3`，闭包了第三次调用的`n`，同理，最终调用第一层`fun`函数为`fun(3,2)`；所以`o`为`2`；\n\n即最终答案：`undefined,0,1,2`\n\n**3、第三行c**\n\n```bash\nvar c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined,?,?,?\n```\n\n根据前面两个例子，可以得知：\n\n`fun(0)`为执行第一层`fun`函数，`.fun(1)`执行的是`fun(0)`返回的第二层`fun`函数，这里语句结束，遂`c`存放的是`fun(1)`的返回值，而不是`fun(0)`的返回值，所以`c`中闭包的也是`fun(1)`第二次执行的`n`的值。`c.fun(2)`执行的是`fun(1)`返回的第二层`fun函数`，`c.fun(3)`执行的**也**是`fun(1)`返回的第二层`fun`函数。\n\n遂：\n\n在第一次调用第一层`fun(0)`时，`o`为`undefined`；\n\n第二次调用 `.fun(1)`时`m`为`1`，此时`fun`闭包了外层函数的`n`，也就是第一次调用的`n=0`，即`m=1`，`n=0`，并在内部调用第一层`fun`函数`fun(1,0);`所以`o`为`0`；\n\n第三次调用`.fun(2)`时`m`为`2`，此时`fun`闭包的是第二次调用的`n=1`，即`m=2`，`n=1`，并在内部调用第一层`fun`函数`fun(2,1);`所以`o`为`1`；\n\n第四次`.fun(3)`时同理，但依然是调用的第二次的返回值，遂最终调用第一层`fun`函数`fun(3,1)`，所以`o`还为`1`\n\n即最终答案：`undefined,0,1,1`\n\n## 后话\n\n这段代码原本是在做一个将异步回调改写为同步调用的组件时的代码，发现了这个坑，对JS的闭包有了更深入的了解。\n\n关于什么是闭包，网上的文章数不胜数，但理解什么是闭包还是要在代码中自己去发现与领悟。\n\n如果要我说什么是闭包，我认为，广义上的闭包就是指一个变量在他自身作用域外被使用了，就叫发生了闭包。\n\n希望读者能通过本文对闭包现象有进一步的了解，如有其它见解或看法，欢迎指正或留言讨论。\n\n\n\n\n\n** 作者：[小小沧海](http://www.cnblogs.com/xxcanghai/)  **\n** 原文地址：[http://www.cnblogs.com/xxcanghai/p/4991870.html](http://www.cnblogs.com/xxcanghai/p/4991870.html) **\n\n","tags":["JavaScript"]},{"title":"强大的CSS3选择器","url":"/2017/03/12/强大的CSS3选择器/","content":"\n\n\n每个前端工程师可能每天都会写一些css，其中选择器是很主要的一部分。但是，大家可能每天写的大多是#id,.class这样的选择器，这并不稀奇，但是如果我们了解并且熟用css3为我们提供的强大并且优雅的选择器，就可以简化我们的代码。\n我在学习和整理css3的选择器的时候都不会去考虑它的浏览器的支持程度，如果有需要，可以在这里查看它的浏览器支持情况：「caniuse.com」。\n\n<!--more-->\n\n## 一、基本选择器\n\n###  1. 通配选择器 「*」\n\n``` bash\n*{margin: 0;padding: 0} //选择页面中的所有元素并设置margin和padding值为0\n.demo *{background:#000} //选择类名为demo的元素下面的所有元素并设置背景为黑色\n```\n\n\n\n### 2.元素选择器 「Element」\n\n``` bash\n body{background:#ccc} //选择body元素 \n ul{background:#fff} //选择列表ul元素\n```\n\n\n\n### 3.ID选择器 「#id」\n\n``` bash\n html:\n <div id=\"demo\"></div>\n css:\n #demo{do something}\n```\n\n\n\n### 4.类选择器 「.class」\n\n``` bash\n html:\n <ul class=\"demo\"></ul>\n css:\n .demo{do something}\n ul.demo{do something} //这样只会选择有demo类名的ul元素\n```\n\n## 二、层次选择器\n\n###  6.后代选择器「E F」\n\n选择匹配E的元素内的所有匹配F的元素。\n\n``` bash\nhtml：\n<div class=\"parent\">\n        <div class=\"child\"></div>\n        <div class=\"child\">\n             <div class=\"c-child\">\n                  <div class=\"c-c-child\"></div>\n            </div>\n        </div>    \n</div>\n\ncss:\n\n.parent div{do something} //会选择parent里面的所有div，不管是子元素.child还是孙元素.c-child和.c-c-child\n```\n\n\n\n###  7.子选择器「E > F」\n\n选择配配E的元素的匹配F的直系子元素。\n\n``` bash\nhtml：\n  <div class=\"parent\">\n          <div class=\"child\"></div>\n          <div class=\"child\">\n               <div class=\"c-child\">\n                    <div class=\"c-c-child\"></div>\n              </div>\n          </div>    \n  </div>\n \n css:\n .parent > div{do something} //只会选择.parent元素的直系子元素，也就是只会选择到 .child元素\n```\n\n\n### 8.相邻兄弟元素选择器「E + F」 \n\nE和F是同辈元素，具有相同的父元素，并且F元素紧邻在E元素的后面，此时可以使用相邻兄弟选择器。\n\n``` bash\nhtml:\n<div>\n    <div class=\"demo\">1</div>\n    <div>2</div>\n    <div>3</div>\n </div>\n \n css:\n \n .demo + div {do something}//会选中内容为2的div\n```\n\n\n### 9.通用兄弟选择器「E ~ F」\n\nE和F是同辈元素，具有相同的父元素，并且F元素在E元素之后，E ~ F将选中E元素后面的所有F元素。\n\n``` bash\nhtml:\n <div>\n     <div class=\"demo\">1</div>\n     <div>2</div>\n     <div>3</div>\n     <div>4</div>\n </div>\n \n css:\n \n.demo ~ div {do something}//会选中内容为2,3,4的div\n```\n\n\n## 三、伪类选择器\n\n### 10.动态伪类选择器「E:link,E:visited,E:active,E:hover,E:focus」\n\n``` bash\nE:link{do something} //选择定义了超链接但链接还未被访问过的元素\nE:visited{do something} //选择定义了超链接并且链接已经被访问过的元素\nE:active{do something} //选择匹配的E元素，且元素被激活，常用在锚点和按钮上\nE:hover{do something} //选择鼠标停留的匹配的E元素\nE:focus{do something} //选择匹配的E元素，且元素获得焦点\n```\n\n### 11.目标伪类选择器「E:target」\n\n选择匹配E的所有元素，且匹配元素被相关URL指向。\n\n\n### 12.语言伪类选择器「E:lang(language)」\n\n用来选择指定了lang属性的元素，其值为language。\n\n``` bash\n html:\n <html lang=\"en-US\"></html>\n \n css:\n :lang(en-US) {do something}\n有时候网页切换不同的语言版本的时候，可以通过这个选择器做一些特殊的处理。\n```\n\n\n### 13.状态伪类选择器「E:checked,E:enabled,E:disabled」\n\n```bash\nE:checked{do something} //匹配表单中被选中的单选按钮或复选按钮\nE:enabled{do something} //匹配所有起用的表单元素\nE:disabled{do something} //匹配所有禁用的表单元素\n```\n\n### 14.结构伪类选择器「E:first-child,E:last-child,E:root,E:nth-child(n),E:nth-last-child(n),E:nth-of-type(n),E:nth-last-of-type(n),E:first-of-type,E:last-of-type,E:only-child,E:only-of-type,E:empty」\n\n \n\n### 14.1 [E:first-child]\n\n用来选取特定元素的第一个子元素。\n\n```bash\nhtml:\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n</ul>\ncss:\nul > li:first-child {do something} //用来选取ul中的第一个li元素\n```\n\n\n### 14.2 [E:last-child]\n\n用来选取特定元素的最后一个子元素。\n\n```bash\n html:\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n     <li>4</li>\n     <li>5</li>\n </ul>\n css:\n ul > li:last-child {do something} //用来选取ul中的最后一个li元素\n```\n\n\n### 14.3 [E:nth-child()],[E:nth-last-child()]\n\n用来选取某个父元素的一个或多个特定的子元素，其中的n可以是数值(从1开始)，也可以是包含n的表达式，也可以是odd(奇数)，even(偶数)。\n\nE:nth-last-child()选择器的使用方法于E:nth-child()是相同的，不同的是E:nth-last-child()选择的元素是从父元素的最后一个子元素开始算起。\n\n```bash\n html:\n  <ul>\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n  </ul>\ncss:\n ul > li:nth-child(2n+1) {do something} //用来选取ul中的第2n+1(奇数)个      li元素\n```\n\n\n### 14.4  [E:root]\n\n用来匹配元素E所在的文档中的根元素，在html文档中根元素就始终是html。\n\n \n\n### 14.5 [E:nth-of-type(),E:nth-last-of-type()]\n\nE:nth-of-type()只计算父元素中指定的某种类型的子元素，当某个元素的子元素类型不只是一种时，使用nth-of-type来选择会比较有用。\n\nE:nth-last-of-type()的用法同E:nth-of-type()相同，不同的是:nth-last-of-type()也是从父元素的最后一个子元素开始算起。\n\nli:nth-of-type(3)的话就会标识它只会选择第三个li元素，别的元素会忽略掉，如：\n\n```bash\n html:\n <ul>\n    <li>1</li>\n    <li>2</li>\n    <div>3</div>\n    <div>4</div>\n    <li>5</li>\n    <li>6</li>\n    <li>7</li>\n    <li>8</li>\n</ul> \nul > li:nth-of-type(3){do something} //会选中内容为5的li元素 \n```\n但是使用nth-child就会是这样：\n\n```bash\n html:\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <div>3</div>\n    <div>4</div>\n    <li>5</li>\n    <li>6</li>\n    <li>7</li>\n    <li>8</li>\n</ul>\nul > li:nth-child(3){do something} //会选中内容为3的div元素\n```\n\n\n### 14.6 [E:first-of-type,E:last-of-type]\n\n:first-of-type和:last-of-type这两个选择器类似于:first-child和:last-child，不同的就是指定了元素的类型。\n\n```bash\nhtml:\n <ul>\n     <div>1</div>\n     <div>2</div>\n     <li>3</li>\n     <li>4</li>\n     <li>5</li>\n     <li>6</li>\n</ul>\nCSS：\nul > li:first-of-type{do something} //会选中内容为3的li元素\n```\n\n\n###  14.7 [E:only-child]\n\n#### 匹配的元素E是其父元素的唯一子元素，也就是说匹配元素的父元素只有一个子元素。\n\n```bash\nhtml:\n<div class=\"demo\">\n   <p>1-1</p>\n   <p>1-2</p>\n</div>\n<div class=\"demo\">\n   <p>2-1</p>\n</div>\ncss:\n.demo > p:only-child{do something}//会选取到内容为2-1的p元素\n```\n\n\n### 14.8 [E:only-of-type]\n\n####  :only-of-type用来选择一个元素，他的类型在他父元素的所有子元素中是唯一的。也就是说，一个父元素有很多子元素，而其中只有一个子元素的类型是唯一的，那么就可以使用:only-of-type来选取这个元素。\n\n这个属性说起来有点绕口，写了个简陋的demo说明意思：[查看源码][运行demo]\n\n \n\n### 14.9 [E:empty]\n\n#### :empty用来选择没有任何内容的元素，哪怕是一个空格都没有的元素。\n\n \n\n### 15 否定伪类选择器「E:not(F)」\n\n#### 可以用来选取所有除了F外的所有元素。\n\n```bash\n1 input:not([type=submit]){do something} //可以用来给表单的所有input元素定义样式，除了submit按钮之外\n```\n\n\n## 四、伪元素\n\n#### 以前我们使用的伪元素是:first-letter,:first-line,:before,:after,这样的。但css3定义的伪元素变成了双冒号，主要用来区分伪类和伪元素。对于IE6-8,仅支持单冒号表示方法，但是其他现代浏览器两种表示方法是都可以的，也就是说在现代浏览器中伪元素使用双冒号和单冒号都是会识别的。\n\n### 16. 「::first-letter」\n\n##### ::first-letter用来选择文本块的第一个字母,常用于文本排版方面。\n\n```bash\n html：\n <div>\n     <p>this is test line.....</p>\n </div>\ncss:\ndiv p::first-letter{do something} //将会选中<p>中的第一个字母t\n```\n\n\n### 17. 「::first-line」\n\n#### ::first-line用于匹配元素的第一行文本，也是常用于文本排版。\n\n```bash\nhtml：\n  <div>\n      <p>\n         this is first line..........省略.......\n         this is the second line ...省略....\n     </p>\n  </div>\n css:\ndiv p::first-line{do something} //将会选中<p>中的第一行文字\n```\n\n\n### 18. 「::before,::after」\n\n#### ::before,::after同我们之前熟用的:before和:after使用方法相同，它们不是指存于标记中的内容，是配合使用content属性可以插入额外内容的位置，尽管生成的内容不会成为DOM的一部分，但它同样可以设置样式。\n\n \n\n### 19. 「::selection」\n\n#### css3新定义的伪元素::selection用来匹配突出显示的文本。但是使用前需要确认浏览器对它的支持程度。\n\n#### 浏览器默认的情况下，我们选中的文本背景是蓝色，字体是白色。通过使用::selection，我们可以改变它的效果。\n\n#### 1 ::selection{background:#ccc;color:red} //这样改写后我们选中的文本背景颜色和文字颜色就可以自定义了\n#### 但是需要注意的是，::selection仅接受两个属性，一个是background，一个是color。\n\n \n\n## 五、属性选择器\n\n#### 在html中，通过给元素添加属性，给以给元素添加一些附加的信息，属性选择器就可以通过定位属性来选取特定的元素。\n\n###  20. 「 E[attr] 」\n\n用来选择有某个属性的元素，不论这个属性的值是什么。\n\n```bash\nhtml:\n<div id=\"demo\">\n  <a href=\"\" id=\"test\"></a>\n  <a href=\"www.taobao.com\" class=\"taobao\"></a>\n  <a href=\"#\"  id=\"show\">\n</div>\ncss:\na[id]{do something} //将会选择具有id属性的a标签\n```\n\n\n###  21. 「 E[attr=val] 」\n\n用来选取具有属性attr并且属性值为val的元素。\n\n```bash\nhtml:\n<div id=\"demo\">\n  <a href=\"\" id=\"test\" title=\"test\"></a>\n  <a href=\"www.taobao.com\" class=\"taobao\"></a>\n  <a href=\"#\"  id=\"show\" title=\"test\">\n/div>\ncss:\na[id=test][title]{do something} //将会选择具有id属性值为test且具有title属性的a标签\n```\n\n\n### 22. 「 E[attr|=val] 」\n\nE[attr|=val]用来选择具有属性attr且属性的值为val或以val-开头的元素(其中-是不可或缺的)。\n\n```bash\nhtml:\n <div id=\"demo\">\n   <a href=\"\" id=\"test\" title=\"test\" lang=\"zh\"></a>\n   <a href=\"www.taobao.com\" class=\"taobao\" lang=\"zh-cn\"></a>\n   <a href=\"#\"  id=\"show\" title=\"test\">\n</div>\ncss:\n a[lang|=zh]{do something} //将会选择具有lang属性值为zh或属性值以zh开头的a标签\n```\n\n\n### 23. 「 E[attr~=val] 」\n\n当某个元素的某个属性具有多个用空格隔开的属性值，此时使用E[attr~=val]只要attr属性多个属性值中有一个于val匹配元素就会被选中。\n\n```bash\nhtml:\n <div id=\"demo\">\n   <a href=\"\" id=\"test\" title=\"test first\"></a>\n   <a href=\"www.taobao.com\" class=\"taobao web\" title=\"second test\">      \n   <a href=\"#\"  id=\"show\" title=\"test\">\n</div>\n css:\n a[title~=test]{do something} //将会选择具有title属性且其中一个属性值为test的a标签\n```\n\n\n### 24. 「 E[attr*=val] 」\n\n这个属性选择器使用了通配符，用来选择具有属性attr并且只要属性值中包含val字符串的元素。也就是说只要所选属性中有val字符串，不管是不是多个用空格分隔的属性值，都将被选中。\n\n```bash\nhtml:\n   <div id=\"demo\">\n     <a href=\"\" id=\"test\" title=\"test first\"></a>\n     <a href=\"www.taobao.com\" class=\"taobao web\" title=\"secondtest\">       </a>\n     <a href=\"#\"  id=\"show\" title=\"testlink\">\n  </div>\n css:\n   a[title*=test]{do something} //将会选择具有title属性且其属性值包含test字符串的a标签\n```","tags":["CSS3"]}]